var documenterSearchIndex = {"docs":
[{"location":"#JOLI-reference-1","page":"JOLI reference","title":"JOLI reference","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Depth = 3","category":"page"},{"location":"#Module-1","page":"JOLI reference","title":"Module","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:module]","category":"page"},{"location":"#Types-1","page":"JOLI reference","title":"Types","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:type]","category":"page"},{"location":"#JOLI.joCoreBlock-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WT}, Tuple{OT}} where WT<:Number where OT<:Integer","page":"JOLI reference","title":"JOLI.joCoreBlock","text":"Universal (Core) block operator composed from different JOLI operators\n\njoCoreBlock(ops::joAbstractLinearOperator...;\n    moffsets::LocalVector{Integer},noffsets::LocalVector{Integer},\n    weights::LocalVector,mextend::Integer,nextend::Integer,name::String)\n\nExample\n\na=rand(ComplexF64,4,5);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,7,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,8);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\nmoff=[0;5;13]\nnoff=[0;6;15]\nBD=joCoreBlock(A,B,C;moffsets=moff,noffsets=noff) # sparse blocks\nBD=joCoreBlock(A,B,C;moffsets=moff,noffsets=noff,mextend=5,nextend=5) # sparse blocks with zero extansion of (mextend,nextend) size\nBD=joCoreBlock(A,B,C) # basic diagonal-corners adjacent blocks\nw=rand(ComplexF64,3)\nBD=joCoreBlock(A,B,C;weights=w) # weighted basic diagonal-corners adjacent blocks\n\nNotes\n\nall given operators must have same domain/range types\nthe domain/range types of joCoreBlock are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDALinearOperator","page":"JOLI reference","title":"JOLI.joDALinearOperator","text":"joDALinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAdistribute","page":"JOLI reference","title":"JOLI.joDAdistribute","text":"joDAdistribute is DAarray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joDAdistribute","text":"julia> joDAdistribute(m [,parts]; [DT])\njulia> joDAdistribute(wpool, m [,parts]; [DT])\njulia> joDAdistribute(m, nvc [,parts]; [DT])\njulia> joDAdistribute(wpool, m, nvc [,parts]; [DT])\njulia> joDAdistribute(dst)\njulia> joDAdistribute(DA)\n\ndefines operator to distribute serial vector into DistributedArrays' vector\n\nSignature\n\njoDAdistribute(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoDAdistribute(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAdistribute(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoDAdistribute(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAdistribute(dst::joPAsetup;gclean::Bool=false)\njoDAdistribute(A::joDAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\ndst: joPAsetup\nDA: joDAdistributedLinearOperator\nglcean: clean DArray after gathering\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joDAdistribute will gather distributed vector into serial vector\n\nExamples\n\njoDAdistribute(5): distribute vector of lenght 5 into default WorkerPool\njoDAdistribute(5,2): distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\njoDAdistribute(5)': gather vector of lenght 5\njoDAdistribute(5,2)': gather multi-vector of lenght 5 with 2 columns\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDAdistributedLinearOperator","page":"JOLI reference","title":"JOLI.joDAdistributedLinearOperator","text":"joDAdistributedLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAdistributingLinearOperator","page":"JOLI reference","title":"JOLI.joDAdistributingLinearOperator","text":"joDAdistributingLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAgather","page":"JOLI reference","title":"JOLI.joDAgather","text":"joDAgather is DAarray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joDAgather","text":"julia> joDAgather(m [,parts]; [DT])\njulia> joDAgather(wpool, m [,parts]; [DT])\njulia> joDAgather(m, nvc [,parts]; [DT])\njulia> joDAgather(wpool, m, nvc [,parts]; [DT])\njulia> joDAgather(dst)\njulia> joDAgather(DA)\n\ndefines operator to gather DistributedArrays' vector into serial vector\n\nSignature\n\njoDAgather(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoDAgather(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAgather(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoDAgather(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAgather(dst::joPAsetup;gclean::Bool=false)\njoDAgather(A::joDAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\ndst: joPAsetup\nDA: joDAdistributedLinearOperator\nglcean: clean DArray after gathering\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joDAgather will distribute serial vector into DistributedArrays' vector\n\nExamples\n\njoDAgather(5): gather vector of lenght 5\njoDAgather(5,2): gather multi-vector of lenght 5 with 2 columns\njoDAgather(5)': distribute vector of lenght 5 into default WorkerPool\njoDAgather(5,2)': distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDAgatheringLinearOperator","page":"JOLI reference","title":"JOLI.joDAgatheringLinearOperator","text":"joDAgatheringLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joKron-Tuple{Vararg{joAbstractLinearOperator,N} where N}","page":"JOLI reference","title":"JOLI.joKron","text":"joKron(ops::joAbstractLinearOperator...)\n\nKronecker product\n\nExample\n\na=rand(ComplexF64,6,4);\nA=joMatrix(a;name=\"A\")\nb=rand(ComplexF64,6,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,4);\nC=joMatrix(c;DDT=ComplexF64,RDT=ComplexF32,name=\"C\")\nK=joKron(A,B,C)\n\nNotes\n\nthe domain and range types of joKron are equal respectively to domain type of rightmost operator and range type of leftmost operator\nall operators in the chain must have consistent passing domain/range types, i.e. domain type of operator on the left have to be the same as range type of operator on the right\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joLinearFunction","page":"JOLI reference","title":"JOLI.joLinearFunction","text":"joLinearFunction type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\nfop_C::Nullable{Function} : conj function\nfMVok : whether fops are rady to handle mvec\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\niMVok::Bool : whether iops are rady to handle mvec\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLinearFunctionInplace","page":"JOLI reference","title":"JOLI.joLinearFunctionInplace","text":"joLinearFunctionInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLinearOperator","page":"JOLI reference","title":"JOLI.joLinearOperator","text":"joLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseLinearFunction","page":"JOLI reference","title":"JOLI.joLooseLinearFunction","text":"joLooseLinearFunction type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\nfop_C::Nullable{Function} : conj function\nfMVok : whether fops are rady to handle mvec\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\niMVok::Bool : whether iops are rady to handle mvec\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseLinearFunctionInplace","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplace","text":"joLooseLinearFunctionInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseMatrix","page":"JOLI reference","title":"JOLI.joLooseMatrix","text":"joLooseMatrix type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\nfop_C::Function : conj matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joLooseMatrix","text":"joLooseMatrix outer constructor\n\njoLooseMatrix(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joLooseMatrix\")\n\nLook up argument names in help to joLooseMatrix type.\n\nExample\n\njoLooseMatrix(rand(4,3)) # implicit domain and range\njoLooseMatrix(rand(4,3);DDT=Float32) # implicit range\njoLooseMatrix(rand(4,3);DDT=Float32,RDT=Float64)\njoLooseMatrix(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joLooseMatrixInplace","page":"JOLI reference","title":"JOLI.joLooseMatrixInplace","text":"joLooseMatrixInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joLooseMatrixInplace","text":"joLooseMatrixInplace outer constructor\n\njoLooseMatrixInplace(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joLooseMatrixInplace\")\n\nLook up argument names in help to joLooseMatrixInplace type.\n\nExample\n\njoLooseMatrixInplace(rand(4,3)) # implicit domain and range\njoLooseMatrixInplace(rand(4,3);DDT=Float32) # implicit range\njoLooseMatrixInplace(rand(4,3);DDT=Float32,RDT=Float64)\njoLooseMatrixInplace(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joMatrix","page":"JOLI reference","title":"JOLI.joMatrix","text":"joMatrix type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\nfop_C::Function : conj matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joMatrix","text":"joMatrix outer constructor\n\njoMatrix(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joMatrix\")\n\nLook up argument names in help to joMatrix type.\n\nExample\n\njoMatrix(rand(4,3)) # implicit domain and range\njoMatrix(rand(4,3);DDT=Float32) # implicit range\njoMatrix(rand(4,3);DDT=Float32,RDT=Float64)\njoMatrix(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joMatrixInplace","page":"JOLI reference","title":"JOLI.joMatrixInplace","text":"joMatrixInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\nfop_C::Function : conj matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joMatrixInplace","text":"joMatrixInplace outer constructor\n\njoMatrixInplace(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joMatrixInplace\")\n\nLook up argument names in help to joMatrixInplace type.\n\nExample\n\njoMatrixInplace(rand(4,3)) # implicit domain and range\njoMatrixInplace(rand(4,3);DDT=Float32) # implicit range\njoMatrixInplace(rand(4,3);DDT=Float32,RDT=Float64)\njoMatrixInplace(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joNumber","page":"JOLI reference","title":"JOLI.joNumber","text":"joNumber type\n\nA number type to use for jo operations with number\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nddt::DDT : number to use when acting on vector to return domain vector\nrdt::RDT : number to use when acting on vector to return range vector\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joNumber-Union{Tuple{NT}, Tuple{NT}} where NT<:Number","page":"JOLI reference","title":"JOLI.joNumber","text":"joNumber outer constructor\n\njoNumber(num)\n\nCreate joNumber with types matching given number\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joNumber-Union{Tuple{RDT}, Tuple{DDT}, Tuple{NT}, Tuple{NT,joAbstractLinearOperator{DDT,RDT}}} where RDT where DDT where NT<:Number","page":"JOLI reference","title":"JOLI.joNumber","text":"joNumber outer constructor\n\njoNumber(num,A::joAbstractLinearOperator{DDT,RDT})\n\nCreate joNumber with types matching the given operator.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup","page":"JOLI reference","title":"JOLI.joPAsetup","text":"joPAsetup type\n\nAtributes\n\nname::String        # name for identification\ndims::Dims          # dimensions of the array\nprocs::Vector{Int}  # ids of workers to use\nchunks::Vector{Int} # number of chunks in each dimension\nidxs::Array{Tuple{Vararg{UnitRange{<:Integer}}}}\ncuts::Vector{Vector{<:Integer}}\nDT::DataType\n\nSee help for outer constructors for joPAsetup.\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joPAsetup-Tuple{DistributedArrays.DArray}","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(in::DArray)\n\nGet joPAsetup represeanting a given DArray\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N,Integer}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,dims,ddim;[DT,][parts,][name])\njulia> joPAsetup(dims,ddim;[DT,][parts,][name])\n\nCreates joPAsetup type\n\nSignature\n\njoPAsetup(wpool::WorkerPool,dims::Dims,ddim::Integer;\n    DT::DataType=joFloat,\n    parts::Union{Vector{Integer},Dims}=joPAsetup_etc.balanced_partition(nworkers(wpool),dims[ddim]),\n    name::String=\"joPAsetup\",)\njoPAsetup(dims::Dims,ddim::Integer;kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\ndims: tuple with array's dimensions\nddim: dimansion to distribute over\nDT: DataType of array's elements\nparts: tuple/vector of the subarray's size on each worker in distributed dimension\nname: name of distributor\n\nExamples\n\njoPAsetup((3,40,5),2;DT=Int8): distribute 2nd dimension over 4 workers\njoPAsetup((3,40,5),2;DT=Int8,parts=(11,11,11,7)): distribute 2nd dimension over 4 workers and specify parts\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,dims;[DT,][chunks,][name])\njulia> joPAsetup(dims;[DT,][chunks,][name])\n\nCreates joPAsetup type - basic distribution\n\nSignatures\n\njoPAsetup(wpool::WorkerPool,dims::Dims;\n    DT::DataType=joFloat,\n    chunks::Vector{Integer}=joPAsetup_etc.default_chunks(dims,sorted(workers(wpool))),\n    name::String=\"joPAsetup\";\njoPAsetup(dims::Dims;kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\ndims: tuple with array's dimensions\nDT: DataType of array's elements\nchunks: vector of number of parts in each dimension\nname: name of distributor\n\nExamples\n\njoPAsetup((3,40,5);DT=Int8): basic distributor for Int8 array (3,40,5)\njoPAsetup((3,40,5);DT=Int8, chunks=[1,nworkers(),1]): basic distributor for Int8 array (3,40,5) forcing distribution in 2nd dimension\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Tuple{Vararg{INT,N} where N},N} where N}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,parts;[name],[DT])\njulia> joPAsetup(parts;[name],[DT])\n\nCreates joPAsetup type with ultimate distribution topology control\n\nSignature\n\njoPAsetup(wpool::WorkerPool,parts::Tuple{Vararg{Tuple{Vararg{Integer}}}};\n    DT::DataType=joFloat,\n    procs::Vector{Integer}=workers(),\n    name::String=\"joPAsetup\")\njoPAsetup(parts::Tuple{Vararg{Tuple{Vararg{INT}}}};kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\nparts: tuple of tuples with subarray's size on each worker\nDT: DataType of array's elements\nname: name of distributor\n\nExamples\n\njoPAsetup(((3,),(10,10,10,10),(5,));DT=Int8): distribute Int8 array (3,40,5) over 2nd dimension\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSALinearOperator","page":"JOLI reference","title":"JOLI.joSALinearOperator","text":"joSALinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAdistribute","page":"JOLI reference","title":"JOLI.joSAdistribute","text":"joSAdistribute is SharedArray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joSAdistribute","text":"julia> joSAdistribute(m [,parts]; [DT])\njulia> joSAdistribute(wpool, m [,parts]; [DT])\njulia> joSAdistribute(m, nvc [,parts]; [DT])\njulia> joSAdistribute(wpool, m, nvc [,parts]; [DT])\njulia> joSAdistribute(dst)\njulia> joSAdistribute(SA)\n\ndefines operator to distribute serial vector into DistributedArrays' vector\n\nSignature\n\njoSAdistribute(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoSAdistribute(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAdistribute(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoSAdistribute(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAdistribute(dst::joPAsetup;gclean::Bool=false)\njoSAdistribute(A::joSAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\ndst: joPAsetup\nSA: joSAdistributedLinearOperator\nglcean: clean SArray after gathering\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joSAdistribute will gather distributed vector into serial vector\n\nExamples\n\njoSAdistribute(5): distribute vector of lenght 5 into default WorkerPool\njoSAdistribute(5,2): distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\njoSAdistribute(5)': gather vector of lenght 5\njoSAdistribute(5,2)': gather multi-vector of lenght 5 with 2 columns\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSAdistributedLinearOperator","page":"JOLI reference","title":"JOLI.joSAdistributedLinearOperator","text":"joSAdistributedLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAdistributingLinearOperator","page":"JOLI reference","title":"JOLI.joSAdistributingLinearOperator","text":"joSAdistributingLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAgather","page":"JOLI reference","title":"JOLI.joSAgather","text":"joSAgather is SharedArray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joSAgather","text":"julia> joSAgather(m [,parts]; [DT])\njulia> joSAgather(wpool, m [,parts]; [DT])\njulia> joSAgather(m, nvc [,parts]; [DT])\njulia> joSAgather(wpool, m, nvc [,parts]; [DT])\njulia> joSAgather(dst)\njulia> joSAgather(SA)\n\ndefines operator to gather DistributedArrays' vector into serial vector\n\nSignature\n\njoSAgather(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoSAgather(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAgather(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoSAgather(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAgather(dst::joPAsetup;gclean::Bool=false)\njoSAgather(A::joSAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\nglcean: clean SArray after gathering\ndst: joPAsetup\nSA: joSAdistributedLinearOperator\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joSAgather will distribute serial vector into DistributedArrays' vector\n\nExamples\n\njoSAgather(5): gather vector of lenght 5\njoSAgather(5,2): gather multi-vector of lenght 5 with 2 columns\njoSAgather(5)': distribute vector of lenght 5 into default WorkerPool\njoSAgather(5,2)': distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSAgatheringLinearOperator","page":"JOLI reference","title":"JOLI.joSAgatheringLinearOperator","text":"joSAgatheringLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#Functions-1","page":"JOLI reference","title":"Functions","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:function]","category":"page"},{"location":"#DistributedArrays.SPMD.scatter-Tuple{AbstractArray,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.SPMD.scatter","text":"julia> scatter(A,d)\n\nScatters SharedArray according to given joPAsetup.\n\nSignature\n\nscatter(a::AbstractArray,d::joPAsetup)\n\nArguments\n\nA: array to ditribute\nd: see help for joPAsetup\n\nNotes\n\nthe type in joPAsetup is ignored here\none of the dimensions must be large enough to hold at least one element on each worker\n\nExamples\n\nscatter(A,d): scatter A using given distributor\nscatter(A,joPAsetup(size(A)...)): scatter A using default distributor settings\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dfill-Tuple{Function,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dfill","text":"julia> dfill(F, d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with elements provided by anonymous function F.\n\nSignature\n\ndfill(F::Function,d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nF: anonymous function of the form I->f(...,map(length,I)))\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nNotes\n\nfunction F will be passed via map(length,I) the tuple with dimensions of local part\none has to pass array type manualy to F\n\nExamples\n\ndfill(I->ones(d.DT,map(length,I)),d): fill a distributed array with ones of type d.DT\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dfill-Tuple{Number,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dfill","text":"julia> dfill(x, d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with x.\n\nSignature\n\ndfill(x::Number,d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndfill(3.,d): fill a distributed array with d.DT(3.)\ndfill(3.,d;DT=Float32): fill a distributed array with Float32(3.)\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.distribute-Tuple{AbstractArray,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.distribute","text":"julia> distribute(A,d)\n\nDistributes DArray according to given joPAsetup.\n\nSignature\n\ndistribute(a::AbstractArray,d::joPAsetup)\n\nArguments\n\nA: array to ditribute\nd: see help for joPAsetup\n\nNotes\n\nthe type in joPAsetup is ignored here\ndistributes over last non-singleton (worker-wise) dimension\none of the dimensions must be large enough to hold at least one element on each worker\n\nExamples\n\ndistribute(A,d): distribute A using given distributor\ndistribute(A,joPAsetup(size(A)...)): distribute A using default distributor settings\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dones-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dones","text":"julia> dones(d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with ones.\n\nSignature\n\ndones(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndones(d): allocate an array of ones\ndones(d,DT=Float32): allocate array of Float32 ones\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.drand-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.drand","text":"julia> drand(d; [DT], [RNG])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled using built-in rand.\n\nSignature\n\ndrand(d::joPAsetup;DT::DataType=d.DT,RNG::AbstractRNG=RandomDevice())\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\nRNG: random-number generator function (see help for rand/randn)\n\nExamples\n\ndrand(d): allocate an array with rand\ndrand(d,DT=Float32): allocate array with rand of Float32\ndrand(d,DT=Float32,RNG=MersenneTwister(1234)): allocate array with rand of Float32 using MersenneTwister() random device\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.drandn-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.drandn","text":"julia> drandn(d; [DT], [RNG])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled using built-in randn.\n\nSignature\n\ndrandn(d::joPAsetup;DT::DataType=d.DT,RNG::AbstractRNG=RandomDevice())\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\nRNG: random-number generator function (see help for rand/randn)\n\nNotes\n\nonly float type are supported by randn (see help for randn)\n\nExamples\n\ndrandn(d): allocate an array with randn\ndrandn(d,DT=Float32): allocate array with randn of Float32\ndrandn(d,DT=Float32,RNG=MersenneTwister(1234)): allocate array with randn of Float32 using MersenneTwister() random device\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dzeros-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dzeros","text":"julia> dzeros(d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with zeros.\n\nSignature\n\ndzeros(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndzeros(d): allocate an array of zeros\ndzeros(d,DT=Float32): allocate array of Float32 zeros\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dalloc-Tuple{Tuple{Vararg{Int64,N}} where N,Vararg{Any,N} where N}","page":"JOLI reference","title":"JOLI.dalloc","text":"julia> dalloc(dims, [...])\n\nAllocates a DistributedArrays.DArray without value assigment.\n\nUse it to allocate quicker the array that will have all elements overwritten.\n\nSignature\n\ndalloc(dims::Dims, [...])\n\nArguments\n\noptional trailing arguments are the same as those accepted by DArray.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dalloc-Tuple{joPAsetup}","page":"JOLI reference","title":"JOLI.dalloc","text":"julia> dalloc(d; [DT])\n\nAllocates a DistributedArrays.DArray, according to given distributor, without value assigment.\n\nUse it to allocate quicker the array that will have all elements overwritten.\n\nSignature\n\ndalloc(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndalloc(d): allocate an array\ndalloc(d,DT=Float32): allocate array and overwite d.DT with Float32\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dcopy-Union{Tuple{T}, Tuple{LinearAlgebra.Transpose{T,#s26} where #s26<:(DistributedArrays.DArray{T,2,A} where A),joPAsetup}} where T","page":"JOLI reference","title":"JOLI.dcopy","text":"julia> dcopy(dtr,[dst])\n\ncopy transpose(DArray) into a new DArray using predefined joPAsetup\n\nSignature\n\ndcopy(Dtr::Transpose{T,<:DArray{T,2}},dst::joPAsetup)\ndcopy(Dtr::Transpose{T,<:DArray{T,2}})\n\nArguments\n\ndtr: transpose(DArray)\ndst: target joPAsetup\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dparts-Union{Tuple{DistributedArrays.DArray{T,N,A} where A}, Tuple{N}, Tuple{T}} where N where T","page":"JOLI reference","title":"JOLI.dparts","text":"julia> dparts(da)\n\nreturn partitioning vector of DArray if partioned in single dimension\n\nSignature\n\ndparts(da::DArray{T,N})\n\nArguments\n\nda: DArray\n\nNotes\n\nif DArray is quasi-distributed (over single worker), dparts returns size(da,N)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joAddSolverAll-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function,Function,Function,Function}} where RDT where DDT","page":"JOLI reference","title":"JOLI.joAddSolverAll","text":"joAddSolver outer constructor\n\njoAddSolverAll(A::joAbstractLinearOperator{DDT,RDT},\n    solver::Function,solver_T::Function,solver_A::Function,solver_C::Function)\n\nCreate joLinearOperator with added specific solver(s) for (jo,[m]vec), distinct for each form of the operator.\n\nExamples\n\nO=joAddSolverAll(O,\n    (s,x)->my_solver(s,x),\n    (s,x)->my_solver_T(s,x),\n    (s,x)->my_solver_A(s,x),\n    (s,x)->my_solver_C(s,x))\n\nO=joAddSolverAll(O,\n    (s,x)->my_solver(s,x),\n    @joNF,\n    (s,x)->my_solver_A(s,x),\n    @joNF)\n\nO=joAddSolverAll(O,\n    (s,x)->my_solver(s,x),\n    @joNF,\n    @joNF,\n    @joNF)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joAddSolverAny-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function}} where RDT where DDT","page":"JOLI reference","title":"JOLI.joAddSolverAny","text":"joAddSolver outer constructor\n\njoAddSolverAny(A::joAbstractLinearOperator{DDT,RDT},solver::Function)\n\nCreate joLinearOperator with added solver for (jo,[m]vec), same for each form of the operator\n\nExample (for all forms of O)\n\nO=joAddSolverAny(O,(s,x)->my_solver(s,x))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joBlock-Union{Tuple{WDT}, Tuple{RVDT}, Tuple{Array{RVDT,1},Vararg{joAbstractLinearOperator,N} where N}} where WDT<:Number where RVDT<:Integer","page":"JOLI reference","title":"JOLI.joBlock","text":"Block operator composed from different square JOLI operators\n\njoBlock(rows::Tuple{Vararg{Int}},ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,4,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,6);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\nd=rand(ComplexF64,6,6);\nD=joMatrix(d;DDT=ComplexF32,RDT=ComplexF64,name=\"D\")\n# either\n    S=joBlock([2,2],A,B,C,D) # basic block in function syntax\n# or\n    S=[A B; C D] # basic block in [] syntax\nw=rand(ComplexF64,4)\nS=joBlock(A,B,C;weights=w) # weighted block\n\nNotes\n\noperators are to be given in row-major order\nall operators in a row must have the same # of rows (M)\nsum of Ns for operators in each row must be the same\nall given operators must have same domain/range types\nthe domain/range types of joBlock are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joBlockDiag-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joBlockDiag","text":"Block-diagonal operator composed from different square JOLI operators\n\njoBlockDiag(ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,8,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,6);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\nBD=joBlockDiag(A,B,C) # basic block diagonal\nw=rand(ComplexF64,3)\nBD=joBlockDiag(A,B,C;weights=w) # weighted block diagonal\n\nNotes\n\nall operators must be square (M(i)==N(i))\nall given operators must have same domain/range types\nthe domain/range types of joBlockDiag are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joBlockDiag-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joBlockDiag","text":"Block-diagonal operator composed from l-times replicated square JOLI operator\n\njoBlockDiag(l::Int,op::joAbstractLinearOperator;weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nw=rand(ComplexF64,3)\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nBD=joBlockDiag(3,A) # basic block diagonal\nBD=joBlockDiag(3,A;weights=w) # weighted block diagonal\n\nNotes\n\nall given operators must have same domain/range types\nthe domain/range types of joBlockDiag are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joCurvelet2D-Tuple{Integer,Integer}","page":"JOLI reference","title":"JOLI.joCurvelet2D","text":"2D Curvelet transform (wrapping) over fast dimensions\n\njoCurvelet2D(n1,n2 [;DDT=joFloat,RDT=DDT,\n    nbscales=#,nbangles_coarse=16,all_crvlts=false,real_crvlts=true,zero_finest=false])\n\nArguments\n\nn1,n2 - image sizes\nnbscales - # of scales (requires #>=default; defaults to max(1,ceil(log2(min(n1,n2))-3)))\nnbangles_coarse - # of angles at coarse scale (requires #%4==0, #>=8; defaults to 16)\nall_crvlts - curvelets at finnest scales (defaults to false)\nreal_crvlts - real transform (defaults to true) and requires real input\nzero_finest - zero out finnest scales (defaults to false)\n\nExamples\n\njoCurvelet2D(32,32) - real transform (64-bit)\njoCurvelet2D(32,32;real_crvlts=false) - complex transform (64-bit)\njoCurvelet2D(32,32;all_crvlts=true) - real transform with curevelts at the finnest scales (64-bit)\njoCurvelet2D(32,32;zero_finest=true) - real transform with zeros at the finnest scales (64-bit)\njoCurvelet2D(32,32;DDT=Float64,real_crvlts=false) - complex transform with real 64-bit input for forward\njoCurvelet2D(32,32;DDT=Float32,RDT=Float64,real_crvlts=false) - complex transform with just precision specification for curvelets\njoCurvelet2D(32,32;DDT=Float32,RDT=ComplexF64,real_crvlts=false) - complex transform with full type specification for curvelets (same as above)\n\nNotes\n\nif DDT:<Real for complex transform then imaginary part will be neglected for transpose/adjoint\nisadjoint test at larger sizes (above 128) might require reseting tollerance to bigger number.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joCurvelet2DnoFFT-Tuple{Integer,Integer}","page":"JOLI reference","title":"JOLI.joCurvelet2DnoFFT","text":"2D Curvelet transform (wrapping) over fast dimensions without FFT\n\njoCurvelet2DnoFFT(n1,n2 [;DDT=joComplex,RDT=DDT,\n    nbscales=#,nbangles_coarse=16,all_crvlts=false,real_crvlts=true,zero_finest=false])\n\nArguments\n\nn1,n2 - image sizes\nnbscales - # of scales (requires #>=default; defaults to max(1,ceil(log2(min(n1,n2))-3)))\nnbangles_coarse - # of angles at coarse scale (requires #%4==0, #>=8; defaults to 16)\nall_crvlts - curvelets at finnest scales (defaults to false)\nreal_crvlts - real transform (defaults to true) and requires real input\nzero_finest - zero out finnest scales (defaults to false)\n\nExamples\n\njoCurvelet2DnoFFT(32,32) - real transform (64-bit)\njoCurvelet2DnoFFT(32,32;real_crvlts=false) - complex transform (64-bit)\njoCurvelet2DnoFFT(32,32;all_crvlts=true) - real transform with curevelts at the finnest scales (64-bit)\njoCurvelet2DnoFFT(32,32;zero_finest=true) - real transform with zeros at the finnest scales (64-bit)\njoCurvelet2DnoFFT(32,32;DDT=Float64,real_crvlts=false) - complex transform with complex 64-bit input for forward\njoCurvelet2DnoFFT(32,32;DDT=Float32,RDT=Float64,real_crvlts=false) - complex transform with just precision specification for curvelets\njoCurvelet2DnoFFT(32,32;DDT=Float32,RDT=ComplexF64,real_crvlts=false) - complex transform with full type specification for curvelets (same as above)\n\nNotes\n\nreal joCurvelet2DnoFFT passed adjoint test while either combined with joDFT, or with isadjont flag userange=true\nisadjoint test at larger sizes (above 128) might require reseting tollerance to bigger number.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT<:Integer where RDT<:Number where DDT<:Number","page":"JOLI reference","title":"JOLI.joDAdistributedLinOp","text":"julia> joDAdistributedLinOp(A,nvc; [parts] [,fclean] [,rclean])\n\nCreate a linear operator working on 2D DAaray in multi-vector (over 2nd dimension) mode.\n\nSignature\n\nfunction joDAdistributedLinOp(wpool::WorkerPool,A::joAbstractLinearOperator{DDT,RDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {DDT<:Number,RDT<:Number,INT<:Integer}\njoDAdistributedLinOp(A::joAbstractLinearOperator{ADDT,ARDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {ADDT<:Number,ARDT<:Number,INT<:Integer}\n\nArguments\n\nA: joAbstractLinearOperator type\nnvc: number of columns in multi-vector\nparts: custom partitioning of 2nd diemnsion \nfclean: close DArray after forward operation\nrclean: close DArray after forward operation in transpose/adjoint mode\n\nExamples\n\njoDAdistributedLinOp(A,30): operator taht will apply A to distributed multivector with 30 columns\n\nNotes\n\nnvc must be >= then # of workers in the WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDCT-Tuple{Vararg{Integer,N} where N}","page":"JOLI reference","title":"JOLI.joDCT","text":"Multi-dimensional DCT transform over fast dimension(s)\n\njoDCT(m[,n[, ...]] [;planned::Bool=true,DDT=joFloat,RDT=DDT])\n\nExamples\n\njoDCT(m) - 1D DCT\njoDCT(m; planned=false) - 1D FFT without the precomputed plan\njoDCT(m,n) - 2D DCT\njoDCT(m; DDT=Float32) - 1D DCT for 32-bit vectors\njoDCT(m; DDT=Float32,RDT=Float64) - 1D DCT for 32-bit input and 64-bit output\n\nNotes\n\nif you intend to use joDCT in remote* calls, you have to either set planned=false or create the operator on the worker\njoDCT is always planned if applied to multi-vector\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDFT-Tuple{Vararg{Integer,N} where N}","page":"JOLI reference","title":"JOLI.joDFT","text":"Multi-dimensional FFT transform over fast dimension(s)\n\njoDFT(m[,n[, ...]]\n        [;planned=true,centered=false,DDT=joFloat,RDT=(DDT:<Real?Complex{DDT}:DDT)])\n\nExamples\n\njoDFT(m) - 1D FFT\njoDFT(m; centered=true) - 1D FFT with centered coefficients\njoDFT(m; planned=false) - 1D FFT without the precomputed plan\njoDFT(m,n) - 2D FFT\njoDFT(m; DDT=Float32) - 1D FFT for 32-bit input\njoDFT(m; DDT=Float32,RDT=ComplexF64) - 1D FFT for 32-bit input and 64-bit output\n\nNotes\n\nif DDT:<Real then imaginary part will be neglected for transpose/adjoint\nif you intend to use joDFT in remote* calls, you have to either set planned=false or create the operator on the worker\njoDFT is always planned if applied to multi-vector\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDWT","page":"JOLI reference","title":"JOLI.joDWT","text":"julia> joDWT(m,wt)\njulia> joDWT(m,n,wt)\n\n1/2-dimensional DWT transform over fast dimension(s) - based on Wavelets.jl. See Wavelets.jl package form more information.\n\nSignature\n\njoDWT(m,[wt=wavelet(WT.haar);L=maxtransformlevels(m),DDT=joFloat,RDT=DDT])\njoDWT(m,n,[wt=wavelet(WT.haar);L=maxtransformlevels(min(m,n)),DDT=joFloat,RDT=DDT])\n\nArguments\n\nM and N: dimentions\nL: number of levels\nwt: wavelet filter\nDDT and RDT: domain and range types\n\nNotes\n\nonly square 2D arrays are supported for now due to limitations of Wavelets.jl package\n\nExamples\n\nwt=wavelet(WT.haar) - define wavelet\njoDWT(m,wt) - 1D DWT\njoDWT(m,n,wt) - 2D DWT\njoDWT(m,wt; DDT=Float32) - 1D DWT for 32-bit vectors\njoDWT(m,wt; DDT=Float32,RDT=Float64) - 1D DWT for 32-bit input and 64-bit output\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joDict-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joDict","text":"Dictionary operator composed from different square JOLI operators\n\njoDict(ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,4,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,4,6);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\n# either\n    D=joDict(A,B,C) # basic dictionary in function syntax\n#or\n    D=[A B C] # basic dictionary in [] syntax\nw=rand(ComplexF64,3)\nD=joDict(A,B,C;weights=w) # weighted dictionary\n\nNotes\n\nall operators must have the same # of rows (M)\nall given operators must have same domain/range types\nthe domain/range types of joDict are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDict-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joDict","text":"Dictionary operator composed from l-times replicated square JOLI operator\n\njoDict(l::Int,op::joAbstractLinearOperator;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nw=rand(ComplexF64,3)\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nD=joDict(3,A) # basic dictionary\nD=joDict(3,A;weights=w) # weighted dictionary\n\nNotes\n\nall operators must have the same # of rows (M)\nall given operators must have same domain/range types\nthe domain/range types of joDict are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDirac-Tuple{Integer}","page":"JOLI reference","title":"JOLI.joDirac","text":"Dirac operator\n\njoDirac(m::Integer;DDT::DataType=joFloat,RDT::DataType=DDT)\n\nArguments\n\nm::Integer - number of columns\n\nExamples\n\nA=joDirac(3)\nA=joDirac(3;DDT=Float32)\nA=joDirac(3;DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joExtend-Tuple{Integer,Symbol}","page":"JOLI reference","title":"JOLI.joExtend","text":"1D extension operator\n\njoExtend(n,pad_type; pad_lower=0,pad_upper=0,DDT=joFloat,RDT=DDT)\n\nArguments\n\nn : size of input vector\npad_type : one of the symbols\n:zeros - pad signal with zeros\n:border - pad signal with values at the edge of the domain\n:mirror - mirror extension of the signal\n:periodic - periodic extension of the signal\npad_lower : number of points to pad on the lower index end (keyword arg, default=0)\npad_upper : number of points to pad on the upper index end (keyword arg, default=0)\n\nExamples\n\nextend a n-length vector with 10 zeros on either side\n\njoExtend(n,:zeros,pad_lower=10,pad_upper=10)\n\nappend, to a n-length vector, so that x[n+1:n+10] = x[n]\n\njoExtend(n,:border,pad_upper=10)\n\nprepend, to a n-length vector, its mirror extension: y=[reverse(x[1:10]);x]\n\njoExtend(n,:mirror,pad_lower=10)\n\nappend, to a n-length vector, its periodic extension: y=[x;x[1:10]]\n\njoExtend(n,:periodic,pad_upper=10)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joGaussian","page":"JOLI reference","title":"JOLI.joGaussian","text":"Gausian matrix\n\njulia> A=joGaussian(M,N;kwargs...)\n\nSignature\n\njoGaussian(M::Integer,N::Integer=M;\n    DDT::DataType=joFloat,RDT::DataType=DDT,\n    implicit::Bool=false,normalized::Bool=false,orthonormal::Bool=false,\n    RNG::AbstractRNG=Random.seed!())\n\nArguments\n\nM,N: size\noptional\nDDT,RDT: keyword domain/range DataType\nimplicit: keyword element-free operator if true\nnormalized: keyword normalized (unit global-norm for explicit or unit-column norm for implicit) operator if true\northonormal: keyword explict orthonormal operator if true (above implicit/normalized is ignorred); requires M<=N\nRNG: keyword random number generator function with explicit seeding\n\nNotes\n\nAbstractRNG has to support seeding (RNG.seed atribute to type); e.g. RandomDevice() will not work\n\nExamples\n\nA=joGaussian(M,N): not-normalized and explict dense matrix\nA=joGaussian(M,orthonormal=true): explicit orthonormal dense matrix\nA=joGaussian(M,implicit=true): not-normalized and element-free operator\nA=joGaussian(M,normalized=true): normalized and explict dense matrix\nA=joGaussian(M,implicit=true,normalized=true): normalized and element-free operator\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinInterp1D-Tuple{Any,Any,Any}","page":"JOLI reference","title":"JOLI.joLinInterp1D","text":"julia> joLinInterp1D(xin,xout,T)\n\n1D Linear interpolation operator\n\nArguments\n\nxin  - input grid\nxout - output grid\nT    - vector data type\n\nSignature\n\njoLinInterp1D(xin,xout,T)\n\nNotes\n\nThe interval [minimum(xout),maximum(xout)] must be contained in the interval [minimum(xin),maximum(xin)]\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joLinearFunctionAll","page":"JOLI reference","title":"JOLI.joLinearFunctionAll","text":"joLinearFunction outer constructor\n\njoLinearFunctionAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLinearFunctionAll\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionFwd","page":"JOLI reference","title":"JOLI.joLinearFunctionFwd","text":"joLinearFunction outer constructor\n\njoLinearFunctionFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLinearFunctionFwd\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionFwd_A","page":"JOLI reference","title":"JOLI.joLinearFunctionFwd_A","text":"joLinearFunction outer constructor\n\njoLinearFunctionFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLinearFunctionFwd_A\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionFwd_T","page":"JOLI reference","title":"JOLI.joLinearFunctionFwd_T","text":"joLinearFunction outer constructor\n\njoLinearFunctionFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLinearFunctionFwd_T\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceAll","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceAll","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceFwd","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceFwd","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceFwd_A","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceFwd_A","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceFwd_A\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceFwd_T","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceFwd_T","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceFwd_T\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplace_A","page":"JOLI reference","title":"JOLI.joLinearFunctionInplace_A","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplace_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplace_A\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplace_T","page":"JOLI reference","title":"JOLI.joLinearFunctionInplace_T","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplace_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplace_T\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunction_A","page":"JOLI reference","title":"JOLI.joLinearFunction_A","text":"joLinearFunction outer constructor\n\njoLinearFunction_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLinearFunction_A\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunction_T","page":"JOLI reference","title":"JOLI.joLinearFunction_T","text":"joLinearFunction outer constructor\n\njoLinearFunction_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLinearFunction_T\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionAll","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionAll","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionAll\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionFwd","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionFwd","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionAll\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionFwd_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionFwd_A","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionFwd_A\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionFwd_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionFwd_T","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionFwd_T\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceAll","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceAll","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceFwd","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceFwd","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceFwd_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceFwd_A","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceFwd_A\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceFwd_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceFwd_T","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceFwd_T\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplace_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplace_A","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplace_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplace_A\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplace_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplace_T","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplace_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplace_T\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunction_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunction_A","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunction_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLooseLinearFunction_A\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunction_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunction_T","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunction_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLooseLinearFunction_T\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joMask-Tuple{BitArray{1}}","page":"JOLI reference","title":"JOLI.joMask","text":"Mask operator\n\njoMask(mask[;DDT=joFloat,RDT=DDT,makecopy=true])\n\nArguments\n\nmask::BitArray{1} - BitArray mask of true indecies\n\nExamples\n\nmask=falses(3)\nmask[[1,3]]=true\nA=joMask(mask)\nA=joMask(mask;DDT=Float32)\nA=joMask(mask;DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joMask-Union{Tuple{VDT}, Tuple{Integer,Array{VDT,1}}} where VDT<:Integer","page":"JOLI reference","title":"JOLI.joMask","text":"Mask operator\n\njoMask(n,idx[;DDT=joFloat,RDT=DDT])\n\nArguments\n\nn::Integer - size of square operator\nidx::Vector{Integer} - vector of true indecies\n\nExamples\n\nA=joMask(3,[1,3])\nA=joMask(3,[1,3];DDT=Float32)\nA=joMask(3,[1,3];DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joNFFT","page":"JOLI reference","title":"JOLI.joNFFT","text":"1D NFFT transform over fast dimension (wrapper to https://github.com/tknopp/NFFT.jl/tree/master)\n\njoNFFT(N,nodes::Vector{joFloat} [,m=4,sigma=2.0,window=:kaiser_bessel,K=2000;centered=false,DDT=joComplex,RDT=DDT])\n\nExamples\n\njoNFFT(N,nodes) - 1D NFFT\n\nNotes\n\nNFFT always uses ComplexF64 vectors internally\nsee https://github.com/tknopp/NFFT.jl/tree/master for docs for optional parameters to NFFTplan\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joOuterProd-Union{Tuple{VDT}, Tuple{UDT}, Tuple{Union{Union{Array{UDT,1}, SubArray{UDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,1} where Ti} where dA<:(Array{UDT,N} where N), Union{Array{UDT,2}, LinearAlgebra.Adjoint{UDT,Array{UDT,2}}, LinearAlgebra.Transpose{UDT,Array{UDT,2}}, SubArray{UDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,2} where Ti} where dA<:(Array{UDT,N} where N)},Union{Union{Array{VDT,1}, SubArray{VDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,1} where Ti} where dA<:(Array{VDT,N} where N), Union{Array{VDT,2}, LinearAlgebra.Adjoint{VDT,Array{VDT,2}}, LinearAlgebra.Transpose{VDT,Array{VDT,2}}, SubArray{VDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,2} where Ti} where dA<:(Array{VDT,N} where N)}}} where VDT<:Number where UDT<:Number","page":"JOLI reference","title":"JOLI.joOuterProd","text":"julia> joOuterProd(U,V)\n\n% Memory efficient implemtation of operator A = U*V'\n\nSignature\n\n% joOuterProd(U::LocalVecOrMat{UDT},V::LocalVecOrMat{VDT};\n    DDT::DataType=joFloat,RDT::DataType=promote_type(UDT,VDT,DDT),name::String=\"joOuterProd\")\n        where {UDT<:Number,VDT<:Number}\n\nArguments\n\nU: left vector or matrix\nV: right vector or matrix\n\nNotes\n\n2nd dimension of U and V must match\n\nExamples\n\nA=joOuterProd(rand(4),rand(5))\nA=joOuterProd(rand(4,2),rand(5,2))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joRestriction-Union{Tuple{idxdt}, Tuple{Integer,Union{Array{idxdt,1}, SubArray{idxdt,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{idxdt,Ti,1} where Ti} where dA<:(Array{idxdt,N} where N)}} where idxdt<:Integer","page":"JOLI reference","title":"JOLI.joRestriction","text":"Restriction operator\n\njoRestriction(n,idx[;DDT=joFloat,RDT=DDT,makecopy=true])\n\nArguments\n\nn::Integer - number of columns\nidx::LocalVector{Int} - vector of indecies\n\nExamples\n\nA=joRestriction(3,[1,3])\nA=joRestriction(3,[1,3];DDT=Float32)\nA=joRestriction(3,[1,3];DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joRomberg-Tuple{Vararg{Integer,N} where N}","page":"JOLI reference","title":"JOLI.joRomberg","text":"A random comvolution based on Romberg 08\n\njulia> A = joRomberg(n1[,n2[...]];kwargs...)\n\nSignature\n\njoRomberg(dims::Integer...;\n    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joRomberg\")\n\nArguments\n\nn1[,n2[...]]: dimensions of the image; M=N=prod(ni)\nDDT/RDT: domain/range DatType\nname: custom name\n\nExamples\n\nA=joRomberg(9)\nA=joRomberg(9,11)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT<:Integer where RDT<:Number where DDT<:Number","page":"JOLI reference","title":"JOLI.joSAdistributedLinOp","text":"julia> joSAdistributedLinOp(A,nvc; [parts] [,fclean] [,rclean])\n\nCreate a linear operator working on 2D SharedArray in multi-vector (over 2nd dimension) mode.\n\nSignature\n\nfunction joSAdistributedLinOp(wpool::WorkerPool,A::joAbstractLinearOperator{DDT,RDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {DDT<:Number,RDT<:Number,INT<:Integer}\njoSAdistributedLinOp(A::joAbstractLinearOperator{ADDT,ARDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {ADDT<:Number,ARDT<:Number,INT<:Integer}\n\nArguments\n\nA: joAbstractLinearOperator type\nnvc: number of columns in multi-vector\nparts: custom partitioning of 2nd diemnsion \nfclean: close SArray after forward operation\nrclean: close SArray after forward operation in transpose/adjoint mode\n\nExamples\n\njoSAdistributedLinOp(A,30): operator taht will apply A to distributed multivector with 30 columns\n\nNotes\n\nnvc must be >= then # of workers in the WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSincInterp-Union{Tuple{I}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where I<:Integer where T<:AbstractFloat","page":"JOLI reference","title":"JOLI.joSincInterp","text":"julia> joSincInterp(xin,xout,r)\n\nsinc interpolation matrix for interpolating functions f defined on grid xin to functions defined on grid xout\n\nSignature\n\njoSincInterp(xin::AbstractArray{T,1},xout::AbstractArray{T,1};r::I=0,DDT=T,RDT=T) where {T<:AbstractFloat,I<:Integer}\n\nArguments\n\nxin  - 1D input grid\nxout - 1D output grid\nr    - kaiser window parameter (default: 0, no windowing)\n\nNotes\n\nIf xout has more than one point, the spacings of xin and xout are normalized to the spacing of xout.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joStack-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joStack","text":"Stack operator composed from different square JOLI operators\n\njoStack(ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,8,4);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,4);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\n# either\n    S=joStack(A,B,C) # basic stack in function syntax\n# or\n    S=[A; B; C] # basic stack in [] syntax\nw=rand(ComplexF64,3)\nS=joStack(A,B,C;weights=w) # weighted stack\n\nNotes\n\nall operators must have the same # of columns (N)\nall given operators must have same domain/range types\nthe domain/range types of joStack are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joStack-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joStack","text":"Stack operator composed from l-times replicated square JOLI operator\n\njoStack(l::Int,op::joAbstractLinearOperator;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nw=rand(ComplexF64,3)\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nS=joStack(3,A) # basic stack\nS=joStack(3,A;weights=w) # weighted stack\n\nNotes\n\nall operators must have the same # of columns (N)\nall given operators must have same domain/range types\nthe domain/range types of joStack are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_PAmode-Tuple{Symbol}","page":"JOLI reference","title":"JOLI.jo_PAmode","text":"\n\n\n\n","category":"method"},{"location":"#JOLI.jo_check_type_match-Tuple{DataType,DataType,String}","page":"JOLI reference","title":"JOLI.jo_check_type_match","text":"Check type match\n\njo_check_type_match(DT1::DataType,DT2::DataType,where::String)\n\nThe bahaviour of the function while types do not match depends on values of jotypemismatchwarn and jotypemismatcherror flags. Use jotypemismatcherrorset to toggle those flags from warning mode to error mode.\n\nEXAMPLE\n\njochecktype_match(Float32,Float64,\"my session\")\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_complex_eltype-Tuple{DataType}","page":"JOLI reference","title":"JOLI.jo_complex_eltype","text":"Type of element of complex data type\n\njo_complex_eltype(DT::DataType)\n\nExample\n\njocomplexeltype(ComplexF32)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_complex_eltype-Union{Tuple{Complex{T}}, Tuple{T}} where T","page":"JOLI reference","title":"JOLI.jo_complex_eltype","text":"Type of element of complex scalar\n\njo_complex_eltype(a::Complex)\n\nExample\n\njocomplexeltype(1.+im*1.)\njocomplexeltype(zero(ComplexF64))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_convert-Union{Tuple{NT}, Tuple{DataType,NT}, Tuple{DataType,NT,Bool}} where NT<:Integer","page":"JOLI reference","title":"JOLI.jo_convert","text":"Convert number to new type\n\njo_convert(DT::DataType,n::Number,warning::Bool=true)\n\nLimitations\n\nconverting integer number to shorter representation will throw an error\nconverting float/complex number to integer will throw an error\nconverting from complex to float drops immaginary part and issues warning; use joconvertwarn_set(false) to turn off the warning\n\nExample\n\njo_convert(ComplexF32,rand())\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_convert-Union{Tuple{VT}, Tuple{DataType,AbstractArray{VT,N} where N}, Tuple{DataType,AbstractArray{VT,N} where N,Bool}} where VT<:Integer","page":"JOLI reference","title":"JOLI.jo_convert","text":"Convert vector to new type\n\njo_convert(DT::DataType,v::AbstractArray,warning::Bool=true)\n\nLimitations\n\nconverting integer array to shorter representation will throw an error\nconverting float/complex array to integer will throw an error\nconverting from complex to float drops immaginary part and issues warning; use joconvertwarn_set(false) to turn off the warning\n\nExample\n\njo_convert(ComplexF32,rand(3))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_convert_warn_set-Tuple{Bool}","page":"JOLI reference","title":"JOLI.jo_convert_warn_set","text":"Set warning mode for jo_convert\n\njo_convert_warn_set(flag::Bool)\n\nExample\n\njoconvertwarn_set(false) turns of the warnings\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_eye","page":"JOLI reference","title":"JOLI.jo_eye","text":"return identity array\n\njo_eye(m::Integer,n::Integer=m)\njo_eye(DT::DataType,m::Integer,n::Integer=m)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_full-Tuple{AbstractArray}","page":"JOLI reference","title":"JOLI.jo_full","text":"return full array\n\njo_full(A::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_iterative_solver4square_set-Tuple{Function}","page":"JOLI reference","title":"JOLI.jo_iterative_solver4square_set","text":"Set default iterative solver for (jo,vec) and square jo\n\njo_iterative_solver4square_set(f::Function)\n\nWhere f must take two arguments (jo,vec) and return vec.\n\nExample (using IterativeSolvers)\n\njoiterativesolver4square_set((A,v)->gmres(A,v))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_iterative_solver4tall_set-Tuple{Function}","page":"JOLI reference","title":"JOLI.jo_iterative_solver4tall_set","text":"Set default iterative solver for (jo,vec) and tall jo\n\njo_iterative_solver4tall_set(f::Function)\n\nWhere f must take two arguments (jo,vec) and return vec.\n\nExample\n\njoiterativesolver4tallset((A,v)->tallsolve(A,v))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_iterative_solver4wide_set-Tuple{Function}","page":"JOLI reference","title":"JOLI.jo_iterative_solver4wide_set","text":"Set default iterative solver for (jo,vec) and wide jo\n\njo_iterative_solver4wide_set(f::Function)\n\nWhere f must take two arguments (jo,vec) and return vec.\n\nExample\n\njoiterativesolver4wideset((A,v)->widesolve(A,v))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_jo32bit_set-Tuple{}","page":"JOLI reference","title":"JOLI.jo_jo32bit_set","text":"set default type joInt, joFloat, joComplex to 32 bit\n\nfunction jo_jo32bit_set()\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_jo64bit_set-Tuple{}","page":"JOLI reference","title":"JOLI.jo_jo64bit_set","text":"set default type joInt, joFloat, joComplex to 64 bit\n\nfunction jo_jo64bit_set()\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_joComplex_set","page":"JOLI reference","title":"JOLI.jo_joComplex_set","text":"set default complex type joComplex\n\nfunction jo_joComplex_set(DT::DataType=joComplex)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_joFloat_set","page":"JOLI reference","title":"JOLI.jo_joFloat_set","text":"set default float type joFloat\n\nfunction jo_joFloat_set(DT::DataType=joFloat)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_joInt_set","page":"JOLI reference","title":"JOLI.jo_joInt_set","text":"set default integer type joInt\n\nfunction jo_joInt_set(DT::DataType=joInt)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_joTypes_get-Tuple{}","page":"JOLI reference","title":"JOLI.jo_joTypes_get","text":"get default types joInt, joFloat, joComplex\n\nfunction jo_joTypes_get()\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_precision_type-Union{Tuple{Tx}, Tuple{Tx}, Tuple{ITx}} where Tx<:Union{Complex{ITx}, ITx} where ITx<:Number","page":"JOLI reference","title":"JOLI.jo_precision_type","text":"Type of the real number or element type of complex number.\n\nExample\n\njoprecisiontype(1.)\njoprecisiontype(1+im*3.)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_speye","page":"JOLI reference","title":"JOLI.jo_speye","text":"return sparse identity array\n\njo_speye(m::Integer,n::Integer=m)\njo_speye(DT::DataType,m::Integer,n::Integer=m)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_type_mismatch_error_set-Tuple{Bool}","page":"JOLI reference","title":"JOLI.jo_type_mismatch_error_set","text":"Toggle between warning and error for type mismatch\n\njo_type_mismatch_error_set(flag::Bool)\n\nExamples\n\njotypemismatcherrorset(false) turns on warnings instead of errors\njotypemismatcherrorset(true) reverts to errors\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.salloc-Tuple{joPAsetup}","page":"JOLI reference","title":"JOLI.salloc","text":"julia> salloc(d; [DT])\n\nAllocates a SharedArray according to given distributor\n\nSignature\n\nsalloc(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\nsalloc(d): allocate an array\nsalloc(d,DT=Float32): allocate array and overwite d.DT with Float32\n\n\n\n\n\n","category":"method"},{"location":"#Constants-1","page":"JOLI reference","title":"Constants","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:constant]","category":"page"},{"location":"#Macros-1","page":"JOLI reference","title":"Macros","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:macro]","category":"page"},{"location":"#JOLI.@joNF-Tuple{Expr}","page":"JOLI reference","title":"JOLI.@joNF","text":"Nullable{Function} macro for given function\n\n@joNF ... | @joNF(...)\n\n\n\n\n\n","category":"macro"},{"location":"#JOLI.@joNF-Tuple{}","page":"JOLI reference","title":"JOLI.@joNF","text":"Nullable{Function} macro for null function\n\n@joNF\n\n\n\n\n\n","category":"macro"},{"location":"#Index-1","page":"JOLI reference","title":"Index","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"","category":"page"}]
}
