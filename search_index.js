var documenterSearchIndex = {"docs":
[{"location":"#JOLI-reference-1","page":"JOLI reference","title":"JOLI reference","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Depth = 3","category":"page"},{"location":"#Module-1","page":"JOLI reference","title":"Module","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:module]","category":"page"},{"location":"#JOLI.JOLI","page":"JOLI reference","title":"JOLI.JOLI","text":"Julia Operator LIbrary (JOLI) is a package for creating algebraic operators (currently linear only) and use them in a way that tries to mimic the mathematical formulas of basics algebra.\n\nThe package was created in SLIM group at the University of British Columbia for their work in seismic imaging and modelling.\n\nJOLI has a collection of methods that allow creating and use of element-free operators, operators created from explicit Matrices, and composing all of those into complex formulas that are not explicitly executed until they act on the Vector or Matrix. '*', '+', '-' and etc... operations are supported in any mathematically valid combination of operators and vectors as long as vector is on the right side of the operator. Composite operators can be defined before they are used to act on vectors.\n\nJOLI operators support operations like adjoint, transpose, and conjugate for element-free operators provided that enough functionality is provided when constructing JOLI operator.\n\nJOLI operators support and enforce consistency of domain and range data types for operators with both vectors acted upon and created by operators. JOLI also has the functionality that allows easily to switch precision of computations using global type definitions.\n\nContrary to other linear-operators Julia packages, JOLI operators act on matrices as if those were column-wise collections of vectors. I.e. JOLI operator does not treat explicit matrix on left side of '*' as another operator, and will act on it immediately. Such behaviour is convenient for implementation of Kronecker product.\n\n\n\n\n\n","category":"module"},{"location":"#Types-1","page":"JOLI reference","title":"Types","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:type]","category":"page"},{"location":"#JOLI.joCoreBlock-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WT}, Tuple{OT}} where WT<:Number where OT<:Integer","page":"JOLI reference","title":"JOLI.joCoreBlock","text":"Universal (Core) block operator composed from different JOLI operators\n\njoCoreBlock(ops::joAbstractLinearOperator...;\n    moffsets::LocalVector{Integer},noffsets::LocalVector{Integer},\n    weights::LocalVector,mextend::Integer,nextend::Integer,name::String)\n\nExample\n\na=rand(ComplexF64,4,5);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,7,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,8);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\nmoff=[0;5;13]\nnoff=[0;6;15]\nBD=joCoreBlock(A,B,C;moffsets=moff,noffsets=noff) # sparse blocks\nBD=joCoreBlock(A,B,C;moffsets=moff,noffsets=noff,mextend=5,nextend=5) # sparse blocks with zero extansion of (mextend,nextend) size\nBD=joCoreBlock(A,B,C) # basic diagonal-corners adjacent blocks\nw=rand(ComplexF64,3)\nBD=joCoreBlock(A,B,C;weights=w) # weighted basic diagonal-corners adjacent blocks\n\nNotes\n\nall given operators must have same domain/range types\nthe domain/range types of joCoreBlock are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDALinearOperator","page":"JOLI reference","title":"JOLI.joDALinearOperator","text":"joDALinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAdistribute","page":"JOLI reference","title":"JOLI.joDAdistribute","text":"joDAdistribute is DAarray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joDAdistribute","text":"julia> joDAdistribute(m [,parts]; [DT])\njulia> joDAdistribute(wpool, m [,parts]; [DT])\njulia> joDAdistribute(m, nvc [,parts]; [DT])\njulia> joDAdistribute(wpool, m, nvc [,parts]; [DT])\njulia> joDAdistribute(dst)\njulia> joDAdistribute(DA)\n\ndefines operator to distribute serial vector into DistributedArrays' vector\n\nSignature\n\njoDAdistribute(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoDAdistribute(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAdistribute(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoDAdistribute(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAdistribute(dst::joPAsetup;gclean::Bool=false)\njoDAdistribute(A::joDAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\ndst: joPAsetup\nDA: joDAdistributedLinearOperator\nglcean: clean DArray after gathering\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joDAdistribute will gather distributed vector into serial vector\n\nExamples\n\njoDAdistribute(5): distribute vector of lenght 5 into default WorkerPool\njoDAdistribute(5,2): distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\njoDAdistribute(5)': gather vector of lenght 5\njoDAdistribute(5,2)': gather multi-vector of lenght 5 with 2 columns\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDAdistributedLinearOperator","page":"JOLI reference","title":"JOLI.joDAdistributedLinearOperator","text":"joDAdistributedLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAdistributingLinearOperator","page":"JOLI reference","title":"JOLI.joDAdistributingLinearOperator","text":"joDAdistributingLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAgather","page":"JOLI reference","title":"JOLI.joDAgather","text":"joDAgather is DAarray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joDAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joDAgather","text":"julia> joDAgather(m [,parts]; [DT])\njulia> joDAgather(wpool, m [,parts]; [DT])\njulia> joDAgather(m, nvc [,parts]; [DT])\njulia> joDAgather(wpool, m, nvc [,parts]; [DT])\njulia> joDAgather(dst)\njulia> joDAgather(DA)\n\ndefines operator to gather DistributedArrays' vector into serial vector\n\nSignature\n\njoDAgather(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoDAgather(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAgather(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoDAgather(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoDAgather(dst::joPAsetup;gclean::Bool=false)\njoDAgather(A::joDAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\ndst: joPAsetup\nDA: joDAdistributedLinearOperator\nglcean: clean DArray after gathering\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joDAgather will distribute serial vector into DistributedArrays' vector\n\nExamples\n\njoDAgather(5): gather vector of lenght 5\njoDAgather(5,2): gather multi-vector of lenght 5 with 2 columns\njoDAgather(5)': distribute vector of lenght 5 into default WorkerPool\njoDAgather(5,2)': distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDAgatheringLinearOperator","page":"JOLI reference","title":"JOLI.joDAgatheringLinearOperator","text":"joDAgatheringLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joKron-Tuple{Vararg{joAbstractLinearOperator,N} where N}","page":"JOLI reference","title":"JOLI.joKron","text":"joKron(ops::joAbstractLinearOperator...)\n\nKronecker product\n\nExample\n\na=rand(ComplexF64,6,4);\nA=joMatrix(a;name=\"A\")\nb=rand(ComplexF64,6,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,4);\nC=joMatrix(c;DDT=ComplexF64,RDT=ComplexF32,name=\"C\")\nK=joKron(A,B,C)\n\nNotes\n\nthe domain and range types of joKron are equal respectively to domain type of rightmost operator and range type of leftmost operator\nall operators in the chain must have consistent passing domain/range types, i.e. domain type of operator on the left have to be the same as range type of operator on the right\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joLinearFunction","page":"JOLI reference","title":"JOLI.joLinearFunction","text":"joLinearFunction type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\nfop_C::Nullable{Function} : conj function\nfMVok : whether fops are rady to handle mvec\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\niMVok::Bool : whether iops are rady to handle mvec\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLinearFunctionInplace","page":"JOLI reference","title":"JOLI.joLinearFunctionInplace","text":"joLinearFunctionInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLinearOperator","page":"JOLI reference","title":"JOLI.joLinearOperator","text":"joLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseLinearFunction","page":"JOLI reference","title":"JOLI.joLooseLinearFunction","text":"joLooseLinearFunction type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\nfop_C::Nullable{Function} : conj function\nfMVok : whether fops are rady to handle mvec\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\niMVok::Bool : whether iops are rady to handle mvec\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseLinearFunctionInplace","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplace","text":"joLooseLinearFunctionInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward function\nfop_T::Nullable{Function} : transpose function\nfop_A::Nullable{Function} : adjoint function\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseMatrix","page":"JOLI reference","title":"JOLI.joLooseMatrix","text":"joLooseMatrix type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\nfop_C::Function : conj matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joLooseMatrix","text":"joLooseMatrix outer constructor\n\njoLooseMatrix(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joLooseMatrix\")\n\nLook up argument names in help to joLooseMatrix type.\n\nExample\n\njoLooseMatrix(rand(4,3)) # implicit domain and range\njoLooseMatrix(rand(4,3);DDT=Float32) # implicit range\njoLooseMatrix(rand(4,3);DDT=Float32,RDT=Float64)\njoLooseMatrix(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joLooseMatrixInplace","page":"JOLI reference","title":"JOLI.joLooseMatrixInplace","text":"joLooseMatrixInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joLooseMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joLooseMatrixInplace","text":"joLooseMatrixInplace outer constructor\n\njoLooseMatrixInplace(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joLooseMatrixInplace\")\n\nLook up argument names in help to joLooseMatrixInplace type.\n\nExample\n\njoLooseMatrixInplace(rand(4,3)) # implicit domain and range\njoLooseMatrixInplace(rand(4,3);DDT=Float32) # implicit range\njoLooseMatrixInplace(rand(4,3);DDT=Float32,RDT=Float64)\njoLooseMatrixInplace(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joMatrix","page":"JOLI reference","title":"JOLI.joMatrix","text":"joMatrix type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\nfop_C::Function : conj matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joMatrix-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joMatrix","text":"joMatrix outer constructor\n\njoMatrix(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joMatrix\")\n\nLook up argument names in help to joMatrix type.\n\nExample\n\njoMatrix(rand(4,3)) # implicit domain and range\njoMatrix(rand(4,3);DDT=Float32) # implicit range\njoMatrix(rand(4,3);DDT=Float32,RDT=Float64)\njoMatrix(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joMatrixInplace","page":"JOLI reference","title":"JOLI.joMatrixInplace","text":"joMatrixInplace type\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nname::String : given name\nm::Integer : # of rows\nn::Integer : # of columns\nfop::Function : forward matrix\nfop_T::Function : transpose matrix\nfop_A::Function : adjoint matrix\nfop_C::Function : conj matrix\niop::Nullable{Function} : inverse for fop\niopT::Nullable{Function} : inverse for fopT\niopA::Nullable{Function} : inverse for fopA\niopC::Nullable{Function} : inverse for fopC\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joMatrixInplace-Union{Tuple{AbstractArray{EDT,2}}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joMatrixInplace","text":"joMatrixInplace outer constructor\n\njoMatrixInplace(array::AbstractMatrix;\n         DDT::DataType=eltype(array),\n         RDT::DataType=promote_type(eltype(array),DDT),\n         name::String=\"joMatrixInplace\")\n\nLook up argument names in help to joMatrixInplace type.\n\nExample\n\njoMatrixInplace(rand(4,3)) # implicit domain and range\njoMatrixInplace(rand(4,3);DDT=Float32) # implicit range\njoMatrixInplace(rand(4,3);DDT=Float32,RDT=Float64)\njoMatrixInplace(rand(4,3);name=\"my matrix\") # adding name\n\nNotes\n\nif DDT:<Real for complex matrix then imaginary part will be neglected for transpose/adjoint operator\nif RDT:<Real for complex matrix then imaginary part will be neglected for forward/conjugate operator\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joNumber","page":"JOLI reference","title":"JOLI.joNumber","text":"joNumber type\n\nA number type to use for jo operations with number\n\nTYPE PARAMETERS\n\nDDT::DataType : domain DataType\nRDT::DataType : range DataType\n\nFIELDS\n\nddt::DDT : number to use when acting on vector to return domain vector\nrdt::RDT : number to use when acting on vector to return range vector\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joNumber-Union{Tuple{NT}, Tuple{NT}} where NT<:Number","page":"JOLI reference","title":"JOLI.joNumber","text":"joNumber outer constructor\n\njoNumber(num)\n\nCreate joNumber with types matching given number\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joNumber-Union{Tuple{RDT}, Tuple{DDT}, Tuple{NT}, Tuple{NT,joAbstractLinearOperator{DDT,RDT}}} where RDT where DDT where NT<:Number","page":"JOLI reference","title":"JOLI.joNumber","text":"joNumber outer constructor\n\njoNumber(num,A::joAbstractLinearOperator{DDT,RDT})\n\nCreate joNumber with types matching the given operator.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup","page":"JOLI reference","title":"JOLI.joPAsetup","text":"joPAsetup type\n\nAtributes\n\nname::String        # name for identification\ndims::Dims          # dimensions of the array\nprocs::Vector{Int}  # ids of workers to use\nchunks::Vector{Int} # number of chunks in each dimension\nidxs::Array{Tuple{Vararg{UnitRange{<:Integer}}}}\ncuts::Vector{Vector{<:Integer}}\nDT::DataType\n\nSee help for outer constructors for joPAsetup.\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joPAsetup-Tuple{DistributedArrays.DArray}","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(in::DArray)\n\nGet joPAsetup represeanting a given DArray\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,n;[DT,][name])\njulia> joPAsetup(n;[DT,][name])\n\nCreates joPAsetup type - basic 1D distribution\n\nSignatures\n\njoPAsetup(wpool::WorkerPool,n::Integer;\n    DT::DataType=joFloat,\n    name::String=\"joPAsetup\";\njoPAsetup(n::Integer;kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\nn: length of the vector\nDT: DataType of vector's elements\nname: name of distributor\n\nExamples\n\njoPAsetup(128): basic distributor for joFloat vector\njoPAsetup(40;DT=Int8): basic distributor for Int8 vector\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N,Integer}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,dims,ddim;[DT,][parts,][name])\njulia> joPAsetup(dims,ddim;[DT,][parts,][name])\n\nCreates joPAsetup type\n\nSignature\n\njoPAsetup(wpool::WorkerPool,dims::Dims,ddim::Integer;\n    DT::DataType=joFloat,\n    parts::Union{Vector{Integer},Dims}=joPAsetup_etc.balanced_partition(nworkers(wpool),dims[ddim]),\n    name::String=\"joPAsetup\",)\njoPAsetup(dims::Dims,ddim::Integer;kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\ndims: tuple with array's dimensions\nddim: dimansion to distribute over\nDT: DataType of array's elements\nparts: tuple/vector of the subarray's size on each worker in distributed dimension\nname: name of distributor\n\nExamples\n\njoPAsetup((3,40,5),2;DT=Int8): distribute 2nd dimension over 4 workers\njoPAsetup((3,40,5),2;DT=Int8,parts=(11,11,11,7)): distribute 2nd dimension over 4 workers and specify parts\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Int64,N}} where N}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,dims;[DT,][chunks,][name])\njulia> joPAsetup(dims;[DT,][chunks,][name])\n\nCreates joPAsetup type - basic distribution\n\nSignatures\n\njoPAsetup(wpool::WorkerPool,dims::Dims;\n    DT::DataType=joFloat,\n    chunks::Vector{Integer}=joPAsetup_etc.default_chunks(dims,sorted(workers(wpool))),\n    name::String=\"joPAsetup\";\njoPAsetup(dims::Dims;kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\ndims: tuple with array's dimensions\nDT: DataType of array's elements\nchunks: vector of number of parts in each dimension\nname: name of distributor\n\nExamples\n\njoPAsetup((3,40,5);DT=Int8): basic distributor for Int8 array (3,40,5)\njoPAsetup((3,40,5);DT=Int8, chunks=[1,nworkers(),1]): basic distributor for Int8 array (3,40,5) forcing distribution in 2nd dimension\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPAsetup-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Tuple{Vararg{Tuple{Vararg{INT,N} where N},N} where N}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joPAsetup","text":"julia> joPAsetup(wpool,parts;[name],[DT])\njulia> joPAsetup(parts;[name],[DT])\n\nCreates joPAsetup type with ultimate distribution topology control\n\nSignature\n\njoPAsetup(wpool::WorkerPool,parts::Tuple{Vararg{Tuple{Vararg{Integer}}}};\n    DT::DataType=joFloat,\n    procs::Vector{Integer}=workers(),\n    name::String=\"joPAsetup\")\njoPAsetup(parts::Tuple{Vararg{Tuple{Vararg{INT}}}};kwargs...)\n\nArguments\n\nwpool: WorkerPool instance - defaults to WorkerPool(workers())\nparts: tuple of tuples with subarray's size on each worker\nDT: DataType of array's elements\nname: name of distributor\n\nExamples\n\njoPAsetup(((3,),(10,10,10,10),(5,));DT=Int8): distribute Int8 array (3,40,5) over 2nd dimension\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSALinearOperator","page":"JOLI reference","title":"JOLI.joSALinearOperator","text":"joSALinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAdistribute","page":"JOLI reference","title":"JOLI.joSAdistribute","text":"joSAdistribute is SharedArray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAdistribute-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joSAdistribute","text":"julia> joSAdistribute(m [,parts]; [DT])\njulia> joSAdistribute(wpool, m [,parts]; [DT])\njulia> joSAdistribute(m, nvc [,parts]; [DT])\njulia> joSAdistribute(wpool, m, nvc [,parts]; [DT])\njulia> joSAdistribute(dst)\njulia> joSAdistribute(SA)\n\ndefines operator to distribute serial vector into DistributedArrays' vector\n\nSignature\n\njoSAdistribute(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoSAdistribute(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAdistribute(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoSAdistribute(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAdistribute(dst::joPAsetup;gclean::Bool=false)\njoSAdistribute(A::joSAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\ndst: joPAsetup\nSA: joSAdistributedLinearOperator\nglcean: clean SArray after gathering\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joSAdistribute will gather distributed vector into serial vector\n\nExamples\n\njoSAdistribute(5): distribute vector of lenght 5 into default WorkerPool\njoSAdistribute(5,2): distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\njoSAdistribute(5)': gather vector of lenght 5\njoSAdistribute(5,2)': gather multi-vector of lenght 5 with 2 columns\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSAdistributedLinearOperator","page":"JOLI reference","title":"JOLI.joSAdistributedLinearOperator","text":"joSAdistributedLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAdistributingLinearOperator","page":"JOLI reference","title":"JOLI.joSAdistributingLinearOperator","text":"joSAdistributingLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAgather","page":"JOLI reference","title":"JOLI.joSAgather","text":"joSAgather is SharedArray toggle type & constructor\n\n!!! Do not use it to create the operators\n!!! Use joMatrix and joLinearFunction constructors\n\n\n\n\n\n","category":"type"},{"location":"#JOLI.joSAgather-Union{Tuple{INT}, Tuple{Distributed.WorkerPool,Integer}, Tuple{Distributed.WorkerPool,Integer,Array{INT,1}}} where INT<:Integer","page":"JOLI reference","title":"JOLI.joSAgather","text":"julia> joSAgather(m [,parts]; [DT])\njulia> joSAgather(wpool, m [,parts]; [DT])\njulia> joSAgather(m, nvc [,parts]; [DT])\njulia> joSAgather(wpool, m, nvc [,parts]; [DT])\njulia> joSAgather(dst)\njulia> joSAgather(SA)\n\ndefines operator to gather DistributedArrays' vector into serial vector\n\nSignature\n\njoSAgather(m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),m);\n    kwargs...) where INT<:Integer\njoSAgather(wpool::WorkerPool,m::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),m);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAgather(m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    kwargs...) where INT<:Integer\njoSAgather(wpool::WorkerPool,m::Integer,nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    DT::DataType=joFloat,gclean::Bool=false) where INT<:Integer\njoSAgather(dst::joPAsetup;gclean::Bool=false)\njoSAgather(A::joSAdistributedLinearOperator;gclean::Bool=false)\n\nArguments\n\nm: length of the vector\nnvc: # of columns in multi-vector - if given then multi-vector is distributed over 2nd dimension\nparts: custom partitioning of distributed dimension\nwpool: custom WorkerPool\nDT: DataType for joPAsetup\nglcean: clean SArray after gathering\ndst: joPAsetup\nSA: joSAdistributedLinearOperator\n\nNotes\n\nno type conversions are attempted at the moment (i.e. DT is used as for any other JOLI operator)\nadjoint/transpose of the joSAgather will distribute serial vector into DistributedArrays' vector\n\nExamples\n\njoSAgather(5): gather vector of lenght 5\njoSAgather(5,2): gather multi-vector of lenght 5 with 2 columns\njoSAgather(5)': distribute vector of lenght 5 into default WorkerPool\njoSAgather(5,2)': distribute multi-vector of lenght 5 with 2 columns into default WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSAgatheringLinearOperator","page":"JOLI reference","title":"JOLI.joSAgatheringLinearOperator","text":"joSAgatheringLinearOperator is glueing type & constructor\n\n!!! Do not use it to create the operators\n\n\n\n\n\n","category":"type"},{"location":"#Functions-1","page":"JOLI reference","title":"Functions","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:function]","category":"page"},{"location":"#DistributedArrays.SPMD.scatter-Tuple{AbstractArray,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.SPMD.scatter","text":"julia> scatter(A,d)\n\nScatters SharedArray according to given joPAsetup.\n\nSignature\n\nscatter(a::AbstractArray,d::joPAsetup)\n\nArguments\n\nA: array to ditribute\nd: see help for joPAsetup\n\nNotes\n\nthe type in joPAsetup is ignored here\none of the dimensions must be large enough to hold at least one element on each worker\n\nExamples\n\nscatter(A,d): scatter A using given distributor\nscatter(A,joPAsetup(size(A)...)): scatter A using default distributor settings\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dfill-Tuple{Function,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dfill","text":"julia> dfill(F, d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with elements provided by anonymous function F.\n\nSignature\n\ndfill(F::Function,d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nF: anonymous function of the form I->f(...,map(length,I)))\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nNotes\n\nfunction F will be passed via map(length,I) the tuple with dimensions of local part\none has to pass array type manualy to F\n\nExamples\n\ndfill(I->ones(d.DT,map(length,I)),d): fill a distributed array with ones of type d.DT\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dfill-Tuple{Number,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dfill","text":"julia> dfill(x, d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with x.\n\nSignature\n\ndfill(x::Number,d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndfill(3.,d): fill a distributed array with d.DT(3.)\ndfill(3.,d;DT=Float32): fill a distributed array with Float32(3.)\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.distribute-Tuple{AbstractArray,joPAsetup}","page":"JOLI reference","title":"DistributedArrays.distribute","text":"julia> distribute(A,d)\n\nDistributes DArray according to given joPAsetup.\n\nSignature\n\ndistribute(a::AbstractArray,d::joPAsetup)\n\nArguments\n\nA: array to ditribute\nd: see help for joPAsetup\n\nNotes\n\nthe type in joPAsetup is ignored here\ndistributes over last non-singleton (worker-wise) dimension\none of the dimensions must be large enough to hold at least one element on each worker\n\nExamples\n\ndistribute(A,d): distribute A using given distributor\ndistribute(A,joPAsetup(size(A)...)): distribute A using default distributor settings\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dones-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dones","text":"julia> dones(d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with ones.\n\nSignature\n\ndones(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndones(d): allocate an array of ones\ndones(d,DT=Float32): allocate array of Float32 ones\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.drand-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.drand","text":"julia> drand(d; [DT], [RNG])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled using built-in rand.\n\nSignature\n\ndrand(d::joPAsetup;DT::DataType=d.DT,RNG::AbstractRNG=RandomDevice())\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\nRNG: random-number generator function (see help for rand/randn)\n\nExamples\n\ndrand(d): allocate an array with rand\ndrand(d,DT=Float32): allocate array with rand of Float32\ndrand(d,DT=Float32,RNG=MersenneTwister(1234)): allocate array with rand of Float32 using MersenneTwister() random device\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.drandn-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.drandn","text":"julia> drandn(d; [DT], [RNG])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled using built-in randn.\n\nSignature\n\ndrandn(d::joPAsetup;DT::DataType=d.DT,RNG::AbstractRNG=RandomDevice())\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\nRNG: random-number generator function (see help for rand/randn)\n\nNotes\n\nonly float type are supported by randn (see help for randn)\n\nExamples\n\ndrandn(d): allocate an array with randn\ndrandn(d,DT=Float32): allocate array with randn of Float32\ndrandn(d,DT=Float32,RNG=MersenneTwister(1234)): allocate array with randn of Float32 using MersenneTwister() random device\n\n\n\n\n\n","category":"method"},{"location":"#DistributedArrays.dzeros-Tuple{joPAsetup}","page":"JOLI reference","title":"DistributedArrays.dzeros","text":"julia> dzeros(d; [DT])\n\nConstructs a DistributedArrays.DArray, according to given distributor, filled with zeros.\n\nSignature\n\ndzeros(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndzeros(d): allocate an array of zeros\ndzeros(d,DT=Float32): allocate array of Float32 zeros\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dalloc-Tuple{Tuple{Vararg{Int64,N}} where N,Vararg{Any,N} where N}","page":"JOLI reference","title":"JOLI.dalloc","text":"julia> dalloc(dims, [...])\n\nAllocates a DistributedArrays.DArray without value assigment.\n\nUse it to allocate quicker the array that will have all elements overwritten.\n\nSignature\n\ndalloc(dims::Dims, [...])\n\nArguments\n\noptional trailing arguments are the same as those accepted by DArray.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dalloc-Tuple{joPAsetup}","page":"JOLI reference","title":"JOLI.dalloc","text":"julia> dalloc(d; [DT])\n\nAllocates a DistributedArrays.DArray, according to given distributor, without value assigment.\n\nUse it to allocate quicker the array that will have all elements overwritten.\n\nSignature\n\ndalloc(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\ndalloc(d): allocate an array\ndalloc(d,DT=Float32): allocate array and overwite d.DT with Float32\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dcopy-Union{Tuple{T}, Tuple{LinearAlgebra.Transpose{T,#s26} where #s26<:(DistributedArrays.DArray{T,2,A} where A),joPAsetup}} where T","page":"JOLI reference","title":"JOLI.dcopy","text":"julia> dcopy(dtr,[dst])\n\ncopy transpose(DArray) into a new DArray using predefined joPAsetup\n\nSignature\n\ndcopy(Dtr::Transpose{T,<:DArray{T,2}},dst::joPAsetup)\ndcopy(Dtr::Transpose{T,<:DArray{T,2}})\n\nArguments\n\ndtr: transpose(DArray)\ndst: target joPAsetup\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.dparts-Union{Tuple{DistributedArrays.DArray{T,N,A} where A}, Tuple{N}, Tuple{T}} where N where T","page":"JOLI reference","title":"JOLI.dparts","text":"julia> dparts(da)\n\nreturn partitioning vector of DArray if partioned in single dimension\n\nSignature\n\ndparts(da::DArray{T,N})\n\nArguments\n\nda: DArray\n\nNotes\n\nif DArray is quasi-distributed (over single worker), dparts returns size(da,N)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joAddSolverAll-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function,Function,Function,Function}} where RDT where DDT","page":"JOLI reference","title":"JOLI.joAddSolverAll","text":"joAddSolver outer constructor\n\njoAddSolverAll(A::joAbstractLinearOperator{DDT,RDT},\n    solver::Function,solver_T::Function,solver_A::Function,solver_C::Function)\n\nCreate joLinearOperator with added specific solver(s) for (jo,[m]vec), distinct for each form of the operator.\n\nExamples\n\nO=joAddSolverAll(O,\n    (s,x)->my_solver(s,x),\n    (s,x)->my_solver_T(s,x),\n    (s,x)->my_solver_A(s,x),\n    (s,x)->my_solver_C(s,x))\n\nO=joAddSolverAll(O,\n    (s,x)->my_solver(s,x),\n    @joNF,\n    (s,x)->my_solver_A(s,x),\n    @joNF)\n\nO=joAddSolverAll(O,\n    (s,x)->my_solver(s,x),\n    @joNF,\n    @joNF,\n    @joNF)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joAddSolverAny-Union{Tuple{RDT}, Tuple{DDT}, Tuple{joAbstractLinearOperator{DDT,RDT},Function}} where RDT where DDT","page":"JOLI reference","title":"JOLI.joAddSolverAny","text":"joAddSolver outer constructor\n\njoAddSolverAny(A::joAbstractLinearOperator{DDT,RDT},solver::Function)\n\nCreate joLinearOperator with added solver for (jo,[m]vec), same for each form of the operator\n\nExample (for all forms of O)\n\nO=joAddSolverAny(O,(s,x)->my_solver(s,x))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joBlock-Union{Tuple{WDT}, Tuple{RVDT}, Tuple{Array{RVDT,1},Vararg{joAbstractLinearOperator,N} where N}} where WDT<:Number where RVDT<:Integer","page":"JOLI reference","title":"JOLI.joBlock","text":"Block operator composed from different square JOLI operators\n\njoBlock(rows::Tuple{Vararg{Int}},ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,4,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,6);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\nd=rand(ComplexF64,6,6);\nD=joMatrix(d;DDT=ComplexF32,RDT=ComplexF64,name=\"D\")\n# either\n    S=joBlock([2,2],A,B,C,D) # basic block in function syntax\n# or\n    S=[A B; C D] # basic block in [] syntax\nw=rand(ComplexF64,4)\nS=joBlock(A,B,C;weights=w) # weighted block\n\nNotes\n\noperators are to be given in row-major order\nall operators in a row must have the same # of rows (M)\nsum of Ns for operators in each row must be the same\nall given operators must have same domain/range types\nthe domain/range types of joBlock are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joBlockDiag-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joBlockDiag","text":"Block-diagonal operator composed from different square JOLI operators\n\njoBlockDiag(ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,8,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,6);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\nBD=joBlockDiag(A,B,C) # basic block diagonal\nw=rand(ComplexF64,3)\nBD=joBlockDiag(A,B,C;weights=w) # weighted block diagonal\n\nNotes\n\nall operators must be square (M(i)==N(i))\nall given operators must have same domain/range types\nthe domain/range types of joBlockDiag are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joBlockDiag-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joBlockDiag","text":"Block-diagonal operator composed from l-times replicated square JOLI operator\n\njoBlockDiag(l::Int,op::joAbstractLinearOperator;weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nw=rand(ComplexF64,3)\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nBD=joBlockDiag(3,A) # basic block diagonal\nBD=joBlockDiag(3,A;weights=w) # weighted block diagonal\n\nNotes\n\nall given operators must have same domain/range types\nthe domain/range types of joBlockDiag are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joCurvelet2D-Tuple{Integer,Integer}","page":"JOLI reference","title":"JOLI.joCurvelet2D","text":"julia> op = joCurvelet2D(n1,n2;[DDT=joFloat,][RDT=DDT,]\n                [nbscales=...,][nbangles_coarse=...,][all_crvlts=...,]\n                [real_crvlts=...,][zero_finest=...,][name=...])\n\n2D Curvelet transform (wrapping) over fast dimensions\n\nSignature\n\nfunction joCurvelet2D(n1::Integer,n2::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,\n        nbscales::Integer=0,\n        nbangles_coarse::Integer=16,\n        all_crvlts::Bool=false,\n        real_crvlts::Bool=true,\n        zero_finest::Bool=false,\n        name::String=\"joCurvelt2D\")\n\nArguments\n\nn1,n2: image sizes\nkeywords\nnbscales: # of scales (requires #>=default; defaults to max(1,ceil(log2(min(n1,n2))-3)))\nnbangles_coarse: # of angles at coarse scale (requires #%4==0, #>=8; defaults to 16)\nall_crvlts: curvelets at finnest scales (defaults to false)\nreal_crvlts: real transform (defaults to true) and requires real input\nzero_finest: zero out finnest scales (defaults to false)\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nif DDT:<Real for complex transform then imaginary part will be neglected for transpose/adjoint\nisadjoint test at larger sizes (above 128) might require reseting tollerance to bigger number.\n\nExamples\n\nreal transform (64-bit)\n\njoCurvelet2D(32,32)\n\ncomplex transform (64-bit)\n\njoCurvelet2D(32,32;real_crvlts=false)\n\nreal transform with curevelts at the finnest scales (64-bit)\n\njoCurvelet2D(32,32;all_crvlts=true)\n\nreal transform with zeros at the finnest scales (64-bit)\n\njoCurvelet2D(32,32;zero_finest=true)\n\ncomplex transform with real 64-bit input for forward\n\njoCurvelet2D(32,32;DDT=Float64,real_crvlts=false)\n\ncomplex transform with just precision specification for curvelets\n\njoCurvelet2D(32,32;DDT=Float32,RDT=Float64,real_crvlts=false)\n\ncomplex transform with full type specification for curvelets (same as above)\n\njoCurvelet2D(32,32;DDT=Float32,RDT=ComplexF64,real_crvlts=false)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joCurvelet2DnoFFT-Tuple{Integer,Integer}","page":"JOLI reference","title":"JOLI.joCurvelet2DnoFFT","text":"julia> op = joCurvelet2DnoFFT(n1,n2;[DDT=joComplex,][RDT=DDT,]\n                [nbscales=...,][nbangles_coarse=...,][all_crvlts=...,]\n                [real_crvlts=...,][zero_finest=...,][name=...])\n\n2D Curvelet transform (wrapping) over fast dimensions without FFT\n\nSignature\n\nfunction joCurvelet2DnoFFT(n1::Integer,n2::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,\n        nbscales::Integer=0,\n        nbangles_coarse::Integer=16,\n        all_crvlts::Bool=false,\n        real_crvlts::Bool=true,\n        zero_finest::Bool=false,\n        name::String=\"joCurvelt2DnoFFT\")\n\nArguments\n\nn1,n2: image sizes\nkeywords\nnbscales: # of scales (requires #>=default; defaults to max(1,ceil(log2(min(n1,n2))-3)))\nnbangles_coarse: # of angles at coarse scale (requires #%4==0, #>=8; defaults to 16)\nall_crvlts: curvelets at finnest scales (defaults to false)\nreal_crvlts: real transform (defaults to true) and requires real input\nzero_finest: zero out finnest scales (defaults to false)\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nreal joCurvelet2DnoFFT passed adjoint test while either combined with joDFT, or with isadjont flag userange=true\nisadjoint test at larger sizes (above 128) might require reseting tollerance to bigger number.\n\nExamples\n\nreal transform (64-bit)\n\njoCurvelet2DnoFFT(32,32)\n\ncomplex transform (64-bit)\n\njoCurvelet2DnoFFT(32,32;real_crvlts=false)\n\nreal transform with curevelts at the finnest scales (64-bit)\n\njoCurvelet2DnoFFT(32,32;all_crvlts=true)\n\nreal transform with zeros at the finnest scales (64-bit)\n\njoCurvelet2DnoFFT(32,32;zero_finest=true)\n\ncomplex transform with complex 64-bit input for forward\n\njoCurvelet2DnoFFT(32,32;DDT=Float64,real_crvlts=false)\n\ncomplex transform with just precision specification for curvelets\n\njoCurvelet2DnoFFT(32,32;DDT=Float32,RDT=Float64,real_crvlts=false)\n\ncomplex transform with full type specification for curvelets (same as above)\n\njoCurvelet2DnoFFT(32,32;DDT=Float32,RDT=ComplexF64,real_crvlts=false)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT<:Integer where RDT<:Number where DDT<:Number","page":"JOLI reference","title":"JOLI.joDAdistributedLinOp","text":"julia> joDAdistributedLinOp(A,nvc; [parts] [,fclean] [,rclean])\n\nCreate a linear operator working on 2D DArray in multi-vector (over 2nd dimension) mode.\n\nSignature\n\nfunction joDAdistributedLinOp(wpool::WorkerPool,A::joAbstractLinearOperator{DDT,RDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {DDT<:Number,RDT<:Number,INT<:Integer}\njoDAdistributedLinOp(A::joAbstractLinearOperator{ADDT,ARDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {ADDT<:Number,ARDT<:Number,INT<:Integer}\n\nArguments\n\nA: joAbstractLinearOperator type\nnvc: number of columns in multi-vector\nparts: custom partitioning of 2nd diemnsion \nfclean: close DArray after forward operation\nrclean: close DArray after forward operation in transpose/adjoint mode\n\nExamples\n\njoDAdistributedLinOp(A,30): operator that will apply A to distributed multivector with 30 columns\n\nNotes\n\nnvc must be >= then # of workers in the WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDCT-Tuple{Vararg{Integer,N} where N}","page":"JOLI reference","title":"JOLI.joDCT","text":"julia> op = joDCT(m[,n[,...]];[planned::Bool=true][,DDT=joFloat][,RDT=DDT])\n\nMulti-dimensional DCT transform over fast dimension(s)\n\nSignature\n\nfunction joDCT(ms::Integer...;\n    planned::Bool=true,\n    DDT::DataType=joFloat,RDT::DataType=DDT,\n    name::String=\"joDCT\")\n\nArguments\n\nm: dimension\noptional\nn,...: more dimensions\nkeywords\nplanned: use DCT plan\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nmultidimensional image must be vectorized\nif you intend to use joDCT in remote* calls, you have to either set planned=false or create the operator on the worker\njoDCT is always planned if applied to multi-vector\n\nExamples\n\n1D DCT\n\njoDCT(m)\n\n1D DCT without the precomputed plan\n\njoDCT(m; planned=false)\n\n2D DCT\n\njoDCT(m,n)\n\nexamples with DDT/RDT\n\njoDCT(m; DDT=Float32)\njoDCT(m; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDFT-Tuple{Vararg{Integer,N} where N}","page":"JOLI reference","title":"JOLI.joDFT","text":"julia> op = joDFT(m[,n[,...]];[plannned=...,][centered=...,][DDT=...,][RDT=...,][name=...])\n\nMulti-dimensional FFT transform over fast dimension(s)\n\nSignature\n\nfunction joDFT(ms::Integer...;\n    planned::Bool=true, centered::Bool=false,\n    DDT::DataType=joFloat, RDT::DataType=(DDT<:Real ? Complex{DDT} : DDT),\n    name::String=\"joDFT\")\n\nArguments\n\nm: dimension\noptional\nn,...: more dimensions\nkeywords\nplanned: use FFTW plan\ncentered: produce centered coefficients\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nmultidimensional image must be vectorized\nif DDT:<Real then imaginary part will be neglected for transpose/adjoint\nif you intend to use joDFT in remote* calls, you have to either set planned=false or create the operator on the worker\njoDFT is always planned if applied to multi-vector\n\nExamples\n\n1D FFT\n\njoDFT(m)\n\n1D FFT with centered coefficients\n\njoDFT(m; centered=true)\n\n1D FFT without the precomputed plan\n\njoDFT(m; planned=false)\n\n2D FFT\n\njoDFT(m,n)\n\nexamples with DDT/RDT\n\njoDFT(m; DDT=Float32)\njoDFT(m; DDT=Float32,RDT=ComplexF64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDWT","page":"JOLI reference","title":"JOLI.joDWT","text":"julia> op = joDWT(m,[n,][wt];[L=...,][DDT=...,][RDT=...])\n\n1/2-dimensional DWT transform over fast dimension(s) - based on Wavelets.jl. See Wavelets.jl package form more information, especially current filter list.\n\nSignature\n\nfunction joDWT(m::Integer,n::Integer,wt::OrthoFilter=wavelet(WT.haar);\n    L::Integer=maxtransformlevels(min(m,n)),\n    DDT::DataType=joFloat,RDT::DataType=DDT,\n    name::String=\"joDWT\")\n\nArguments\n\nm: dimention\noptional\nn: 2nd dimention\nwt: wavelet filter (Haar by default)\nkeywords\nL: number of levels\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nonly square 2D arrays are supported for now due to limitations of Wavelets.jl package\n\nExamples\n\n1D DWT with default wavelet (Haar wavelet)\n\njoDWT(m)\n\ndefine wavelet\n\nwt=wavelet(WT.haar)\n\n1D DWT\n\njoDWT(m,wt)\n\n2D DWT\n\njoDWT(m,n,wt)\n\nexamples with DDT/RDT\n\njoDWT(m,wt; DDT=Float32)\njoDWT(m,wt; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joDiag-Union{Tuple{Union{Array{EDT,1}, SubArray{EDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{EDT,Ti,1} where Ti} where dA<:(Array{EDT,N} where N)}, Tuple{EDT}} where EDT","page":"JOLI reference","title":"JOLI.joDiag","text":"julia> op = joDiag(v;[makecopy=...,][DDT=...,][RDT=...,][name=...])\n\nDiagonal matrix with elements from given vector\n\nSignature\n\nfunction joDiag(v::LocalVector{EDT};makecopy::Bool=true,\n    DDT::DataType=EDT,RDT::DataType=promote_type(EDT,DDT),name::String=\"joDiag\") where {EDT}\n\nArguments\n\nv: vector of diagonal elements\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\njoDiag(rand(m))\n\nexamples with DDT/RDT\n\njoDiag(rand(m); DDT=Float32)\njoDiag(rand(m); DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDict-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joDict","text":"Dictionary operator composed from different square JOLI operators\n\njoDict(ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,4,8);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,4,6);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\n# either\n    D=joDict(A,B,C) # basic dictionary in function syntax\n#or\n    D=[A B C] # basic dictionary in [] syntax\nw=rand(ComplexF64,3)\nD=joDict(A,B,C;weights=w) # weighted dictionary\n\nNotes\n\nall operators must have the same # of rows (M)\nall given operators must have same domain/range types\nthe domain/range types of joDict are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDict-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joDict","text":"Dictionary operator composed from l-times replicated square JOLI operator\n\njoDict(l::Int,op::joAbstractLinearOperator;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nw=rand(ComplexF64,3)\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nD=joDict(3,A) # basic dictionary\nD=joDict(3,A;weights=w) # weighted dictionary\n\nNotes\n\nall operators must have the same # of rows (M)\nall given operators must have same domain/range types\nthe domain/range types of joDict are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joDirac-Tuple{Integer}","page":"JOLI reference","title":"JOLI.joDirac","text":"joDirac(m;[DDT=...,][RDT=...,][name=...])\n\nDirac operator\n\nSignature\n\njoDirac(m::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joDirac\")\n\nArguments\n\nArguments\n\nm: size\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\nA=joDirac(3)\n\nexamples with DDT/RDT\n\nA=joDirac(3; DDT=Float32)\nA=joDirac(3; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joExtend-Tuple{Integer,Symbol}","page":"JOLI reference","title":"JOLI.joExtend","text":"julia> op = joExtend(n,pad_type;[pad_lower=0,][pad_upper=0,][DDT=joFloat,][RDT=DDT])\n\n1D extension operator\n\nSignature\n\nfunction joExtend(n::Integer,pad_type::Symbol;\n    pad_upper::Integer=0,pad_lower::Integer=0,\n    DDT::DataType=joFloat,RDT::DataType=DDT,\n    name=\"joExtend\")\n\nArguments\n\nn : size of input vector\npad_type : one of the symbols\n:zeros : pad signal with zeros\n:border : pad signal with values at the edge of the domain\n:mirror : mirror extension of the signal\n:periodic : periodic extension of the signal\nkeywords\npad_lower : number of points to pad on the lower index end (keyword arg, default=0)\npad_upper : number of points to pad on the upper index end (keyword arg, default=0)\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\nextend a n-length vector with 10 zeros on either side\n\njoExtend(n,:zeros; pad_lower=10,pad_upper=10)\n\nappend, to a n-length vector, so that x[n+1:n+10] = x[n]\n\njoExtend(n,:border; pad_upper=10)\n\nprepend, to n-length vector, its mirror extension: y=[reverse(x[1:10]);x]\n\njoExtend(n,:mirror; pad_lower=10)\n\nappend, to n-length vector, its periodic extension: y=[x;x[1:10]]\n\njoExtend(n,:periodic; pad_upper=10)\n\nexamples with DDT/RDT\n\njoExtend(n,:mirror; pad_lower=10,DDT=Float32)\njoExtend(n,:periodic; pad_upper=10,DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joEye-Tuple{Integer,Integer}","page":"JOLI reference","title":"JOLI.joEye","text":"julia> op = joEye(m,n;[DDT=...,][RDT=...,][name=...])\n\nIdentity matrix - rectangular\n\nSignature\n\njoEye(m::Integer,n::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joEye\")\n\nArguments\n\nm,n: sizes\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\njoEye(m,n)\n\nexamples with DDT/RDT\n\njoEye(m,n; DDT=Float32)\njoEye(m,n; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joEye-Tuple{Integer}","page":"JOLI reference","title":"JOLI.joEye","text":"julia> op = joEye(m;[DDT=...,][RDT=...,][name=...])\n\nIdentity matrix - square\n\nSignature\n\njoEye(m::Integer;DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joEye\")\n\nArguments\n\nm: sizes\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\njoEye(m)\n\nexamples with DDT/RDT\n\njoEye(m; DDT=Float32)\njoEye(m; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joGaussian","page":"JOLI reference","title":"JOLI.joGaussian","text":"Gausian matrix\n\njulia> op = joGaussian(M,[N];\n            [implicit=...,][normalized=...,][orthonormal=...,][RNG=...,]\n            [DDT=...,][RDT=...,][name=...])\n\nSignature\n\njoGaussian(M::Integer,N::Integer=M;\n    implicit::Bool=false,normalized::Bool=false,orthonormal::Bool=false,\n    RNG::AbstractRNG=Random.seed!(),\n    DDT::DataType=joFloat,RDT::DataType=DDT,\n    name::String=\"joGaussian\")\n\nArguments\n\nM[,N]: sizes\nkeywords\nimplicit: keyword element-free operator if true\nnormalized: keyword normalized (unit global-norm for explicit or unit-column norm for implicit) operator if true\northonormal: keyword explict orthonormal operator if true (above implicit/normalized is ignorred); requires M<=N\nRNG: keyword random number generator function with explicit seeding\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nAbstractRNG has to support seeding (RNG.seed atribute to type); e.g. RandomDevice() will not work\n\nExamples\n\nnot-normalized and explict dense matrix\n\nA=joGaussian(M,N)\n\nexplicit orthonormal dense matrix\n\nA=joGaussian(M,orthonormal=true)\n\nnot-normalized and element-free operator\n\nA=joGaussian(M,implicit=true)\n\nnormalized and explict dense matrix\n\nA=joGaussian(M,normalized=true)\n\nnormalized and element-free operator\n\nA=joGaussian(M,implicit=true,normalized=true)\n\nexamples with DDT/RDT\n\nA=joGaussian(M,N; DDT=Float32)\nA=joGaussian(M,N; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinInterp1D-Tuple{Any,Any,Any}","page":"JOLI reference","title":"JOLI.joLinInterp1D","text":"julia> joLinInterp1D(xin,xout,T)\n\n1D Linear interpolation operator\n\nArguments\n\nxin  - input grid\nxout - output grid\nT    - vector data type\n\nSignature\n\njoLinInterp1D(xin,xout,T)\n\nNotes\n\nThe interval [minimum(xout),maximum(xout)] must be contained in the interval [minimum(xin),maximum(xin)]\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joLinearFunctionAll","page":"JOLI reference","title":"JOLI.joLinearFunctionAll","text":"joLinearFunction outer constructor\n\njoLinearFunctionAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLinearFunctionAll\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionFwd","page":"JOLI reference","title":"JOLI.joLinearFunctionFwd","text":"joLinearFunction outer constructor\n\njoLinearFunctionFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLinearFunctionFwd\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionFwd_A","page":"JOLI reference","title":"JOLI.joLinearFunctionFwd_A","text":"joLinearFunction outer constructor\n\njoLinearFunctionFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLinearFunctionFwd_A\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionFwd_T","page":"JOLI reference","title":"JOLI.joLinearFunctionFwd_T","text":"joLinearFunction outer constructor\n\njoLinearFunctionFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLinearFunctionFwd_T\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceAll","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceAll","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceFwd","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceFwd","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceFwd_A","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceFwd_A","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceFwd_A\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplaceFwd_T","page":"JOLI reference","title":"JOLI.joLinearFunctionInplaceFwd_T","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplaceFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplaceFwd_T\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplace_A","page":"JOLI reference","title":"JOLI.joLinearFunctionInplace_A","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplace_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplace_A\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunctionInplace_T","page":"JOLI reference","title":"JOLI.joLinearFunctionInplace_T","text":"joLinearFunctionInplace outer constructor\n\njoLinearFunctionInplace_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLinearFunctionInplace_T\")\n\nLook up argument names in help to joLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunction_A","page":"JOLI reference","title":"JOLI.joLinearFunction_A","text":"joLinearFunction outer constructor\n\njoLinearFunction_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLinearFunction_A\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLinearFunction_T","page":"JOLI reference","title":"JOLI.joLinearFunction_T","text":"joLinearFunction outer constructor\n\njoLinearFunction_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLinearFunction_T\")\n\nLook up argument names in help to joLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionAll","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionAll","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionAll\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionFwd","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionFwd","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionAll\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionFwd_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionFwd_A","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionFwd_A\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionFwd_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionFwd_T","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunctionFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,\n    name::String=\"joLooseLinearFunctionFwd_T\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceAll","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceAll","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceAll(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    iop::Function,iop_T::Function,iop_A::Function,iop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceFwd","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceFwd","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceFwd(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,fop_A::Function,fop_C::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceAll\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceFwd_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceFwd_A","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceFwd_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceFwd_A\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplaceFwd_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplaceFwd_T","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplaceFwd_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplaceFwd_T\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplace_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplace_A","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplace_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplace_A\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunctionInplace_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunctionInplace_T","text":"joLooseLinearFunctionInplace outer constructor\n\njoLooseLinearFunctionInplace_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    name::String=\"joLooseLinearFunctionInplace_T\")\n\nLook up argument names in help to joLooseLinearFunctionInplace type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions provide correct DDT & RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunction_A","page":"JOLI reference","title":"JOLI.joLooseLinearFunction_A","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunction_A(m::Integer,n::Integer,\n    fop::Function,fop_A::Function, iop::Function,iop_A::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLooseLinearFunction_A\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joLooseLinearFunction_T","page":"JOLI reference","title":"JOLI.joLooseLinearFunction_T","text":"joLooseLinearFunction outer constructor\n\njoLooseLinearFunction_T(m::Integer,n::Integer,\n    fop::Function,fop_T::Function, iop::Function,iop_T::Function,\n    DDT::DataType,RDT::DataType=DDT;\n    fMVok::Bool=false,iMVok::Bool=false,\n    name::String=\"joLooseLinearFunction_T\")\n\nLook up argument names in help to joLooseLinearFunction type.\n\nNotes\n\nthe developer is responsible for ensuring that used functions take/return correct DDT/RDT\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joMask-Tuple{BitArray{1}}","page":"JOLI reference","title":"JOLI.joMask","text":"joMask(mask;[makecopy=...,][DDT=...,][RDT=...,][name=...])\n\nMask operator with BitArray mask\n\nSignature\n\nfunction joMask(mask::BitArray{1};\n    makecopy::Bool=true,DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joMask\")\n\nArguments\n\nmask: BitArray mask of true indecies\nkeywords\nmakecopy: copy mask array\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\ndefine BitArray mask and operator\n\nmask=falses(3)\nmask[[1,3]]=true\n\nA=joMask(mask)\n\nexamples with RDT/DDT\n\nA=joMask(mask; DDT=Float32)\nA=joMask(mask; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joMask-Union{Tuple{VDT}, Tuple{Integer,Array{VDT,1}}} where VDT<:Integer","page":"JOLI reference","title":"JOLI.joMask","text":"joMask(n,idx;[DDT=...,][RDT=...,][name=...])\n\nMask operator with index array\n\nSignature\n\nfunction joMask(n::Integer,idx::Vector{VDT};\n    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joMask\") where {VDT<:Integer}\n\nArguments\n\nn: size of square operator\nidx: vector of true indecies\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\nA=joMask(3,[1,3])\n\nexamples with DDT/RDT\n\nA=joMask(3,[1,3]; DDT=Float32)\nA=joMask(3,[1,3]; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joNFFT","page":"JOLI reference","title":"JOLI.joNFFT","text":"julia> op = joNFFT(N,nodes[,m=...][,sigma=...][,window=...][,K=...];\n            [centered=...,][DDT=...,][RDT=...,][name=...])\n\n1D NFFT transform over fast dimension (wrapper to https://github.com/tknopp/NFFT.jl)\n\nSignature\n\nfunction joNFFT(N::Integer,pos::Vector{joFloat},\n    m=4,sigma=2.0,window=:kaiser_bessel,K=2000; centered::Bool=false,\n    DDT::DataType=joComplex,RDT::DataType=DDT,name::String=\"joNFFT\")\n\nArguments\n\nN: size\nnodes: nodes' positions\noptional\nsee https://github.com/tknopp/NFFT.jl for info about optional parameters to NFFTplan: m, sigma, window, and K\nkeywords\ncentered: return centered coefficients\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\nNFFT always uses ComplexF64 vectors internally\n\nExamples\n\n1D NFFT\n\njoNFFT(N,nodes)\n\nexamples with DDT/RDT\n\n% joNFFT(N,nodes; DDT=ComplexF32)\n% joNFFT(N,nodes; DDT=ComplexF32,RDT=ComplexF64)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joOnes","page":"JOLI reference","title":"JOLI.joOnes","text":"julia> op = joOnes(m[,n];[DDT=...,][RDT=...,][name=...])\n\nOperator equivalent to matrix of zerso\n\nSignature\n\njoOnes(m::Integer,n::Integer=m;\n    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joOnes\")\n\nArguments\n\nm: size\noptional\nn: 2nd dimension if not square\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\njoOnes(m)\njoOnes(m,n)\n\nexamples with DDT/RDT\n\njoOnes(m; DDT=Float32)\njoOnes(m; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.joOuterProd-Union{Tuple{VDT}, Tuple{UDT}, Tuple{Union{Union{Array{UDT,1}, SubArray{UDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,1} where Ti} where dA<:(Array{UDT,N} where N), Union{Array{UDT,2}, LinearAlgebra.Adjoint{UDT,Array{UDT,2}}, LinearAlgebra.Transpose{UDT,Array{UDT,2}}, SubArray{UDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{UDT,Ti,2} where Ti} where dA<:(Array{UDT,N} where N)},Union{Union{Array{VDT,1}, SubArray{VDT,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,1} where Ti} where dA<:(Array{VDT,N} where N), Union{Array{VDT,2}, LinearAlgebra.Adjoint{VDT,Array{VDT,2}}, LinearAlgebra.Transpose{VDT,Array{VDT,2}}, SubArray{VDT,2,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{VDT,Ti,2} where Ti} where dA<:(Array{VDT,N} where N)}}} where VDT<:Number where UDT<:Number","page":"JOLI reference","title":"JOLI.joOuterProd","text":"julia> op = joOuterProd(U,V;[DDT=...,][RDT=...,][name=...])\n\nMemory efficient implementation of operator A = U*V'\n\nSignature\n\njoOuterProd(U::LocalVecOrMat{UDT},V::LocalVecOrMat{VDT};\n    DDT::DataType=joFloat,RDT::DataType=promote_type(UDT,VDT,DDT),name::String=\"joOuterProd\")\n        where {UDT<:Number,VDT<:Number}\n\nArguments\n\nU: left vector or matrix\nV: right vector or matrix\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nNotes\n\n2nd dimension of U and V must match\n\nExamples\n\nA=joOuterProd(rand(4),rand(5))\nA=joOuterProd(rand(4,2),rand(5,2))\n\nexamples with DDT/RDT\n\nA=joOuterProd(rand(4),rand(5); DDT=Float32)\nA=joOuterProd(rand(4),rand(5); DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joPermutation-Union{Tuple{Union{Array{T,1}, SubArray{T,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{T,Ti,1} where Ti} where dA<:(Array{T,N} where N)}, Tuple{T}} where T<:Integer","page":"JOLI reference","title":"JOLI.joPermutation","text":"julia> op = joPermutation(perm;[DDT=...,][RDT=...,][name=...])\n\nPermiutation operator\n\nSignature\n\nfunction joPermutation(perm::LocalVector{T};\n    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joPermutation\") where {T<:Integer}\n\nArguments\n\nperm: permiutation vector\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\njoPermutation([3, 1, 2])\n\nexamples with DDT/RDT\n\njoPermutation([3, 1, 2]; DDT=Float32)\njoPermutation([3, 1, 2]; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joRestriction-Union{Tuple{idxdt}, Tuple{Integer,Union{Array{idxdt,1}, SubArray{idxdt,1,dA,I,L} where L where I, SparseArrays.AbstractSparseArray{idxdt,Ti,1} where Ti} where dA<:(Array{idxdt,N} where N)}} where idxdt<:Integer","page":"JOLI reference","title":"JOLI.joRestriction","text":"julia> op = joRestriction(n,idx;[makecopy=...,][DDT=...,][RDT=...,][name=...])\n\nRestriction operator\n\nSignature\n\nfunction joRestriction(n::Integer,idx::LocalVector{idxdt};\n    makecopy::Bool=true,DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joRestriction\")\n        where {idxdt<:Integer}\n\nArguments\n\nn: number of columns\nidx: vector of indecies\nkeywords\nmakecopy: make private copy of indecies vector\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\nA=joRestriction(3,[1,3])\n\nexamples with DDT/RDT\n\nA=joRestriction(3,[1,3];DDT=Float32)\nA=joRestriction(3,[1,3];DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joRomberg-Tuple{Vararg{Integer,N} where N}","page":"JOLI reference","title":"JOLI.joRomberg","text":"julia> op = joRomberg(n1[,n2[,...]];[DDT=...,][RDT=...,][name=...])\n\nA random comvolution based on Romberg 08\n\nSignature\n\njoRomberg(dims::Integer...;\n    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joRomberg\")\n\nArguments\n\nn1[,n2[...]]: dimensions of the image; M=N=prod(ni)\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\nA=joRomberg(9)\nA=joRomberg(9,11)\n\nexamples with DDT/RDT\n\nA=joRomberg(9,11; DDT=Float32)\nA=joRomberg(9,11; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSAdistributedLinOp-Union{Tuple{INT}, Tuple{RDT}, Tuple{DDT}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer}, Tuple{Distributed.WorkerPool,joAbstractLinearOperator{DDT,RDT},Integer,Array{INT,1}}} where INT<:Integer where RDT<:Number where DDT<:Number","page":"JOLI reference","title":"JOLI.joSAdistributedLinOp","text":"julia> joSAdistributedLinOp(A,nvc; [parts] [,fclean] [,rclean])\n\nCreate a linear operator working on 2D SharedArray in multi-vector (over 2nd dimension) mode.\n\nSignature\n\nfunction joSAdistributedLinOp(wpool::WorkerPool,A::joAbstractLinearOperator{DDT,RDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(wpool),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {DDT<:Number,RDT<:Number,INT<:Integer}\njoSAdistributedLinOp(A::joAbstractLinearOperator{ADDT,ARDT},nvc::Integer,\n    parts::Vector{INT}=joPAsetup_etc.balanced_partition(nworkers(),nvc);\n    fclean::Bool=false,rclean::Bool=false) where {ADDT<:Number,ARDT<:Number,INT<:Integer}\n\nArguments\n\nA: joAbstractLinearOperator type\nnvc: number of columns in multi-vector\nparts: custom partitioning of 2nd diemnsion \nfclean: close SArray after forward operation\nrclean: close SArray after forward operation in transpose/adjoint mode\n\nExamples\n\njoSAdistributedLinOp(A,30): operator that will apply A to distributed multivector with 30 columns\n\nNotes\n\nnvc must be >= then # of workers in the WorkerPool\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joSincInterp-Union{Tuple{I}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1}}} where I<:Integer where T<:AbstractFloat","page":"JOLI reference","title":"JOLI.joSincInterp","text":"julia> joSincInterp(xin,xout,r)\n\nsinc interpolation matrix for interpolating functions f defined on grid xin to functions defined on grid xout\n\nSignature\n\njoSincInterp(xin::AbstractArray{T,1},xout::AbstractArray{T,1};r::I=0,DDT=T,RDT=T) where {T<:AbstractFloat,I<:Integer}\n\nArguments\n\nxin  - 1D input grid\nxout - 1D output grid\nr    - kaiser window parameter (default: 0, no windowing)\n\nNotes\n\nIf xout has more than one point, the spacings of xin and xout are normalized to the spacing of xout.\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joStack-Union{Tuple{Vararg{joAbstractLinearOperator,N} where N}, Tuple{WDT}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joStack","text":"Stack operator composed from different square JOLI operators\n\njoStack(ops::joAbstractLinearOperator...;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nb=rand(ComplexF64,8,4);\nB=joMatrix(b;DDT=ComplexF32,RDT=ComplexF64,name=\"B\")\nc=rand(ComplexF64,6,4);\nC=joMatrix(c;DDT=ComplexF32,RDT=ComplexF64,name=\"C\")\n# either\n    S=joStack(A,B,C) # basic stack in function syntax\n# or\n    S=[A; B; C] # basic stack in [] syntax\nw=rand(ComplexF64,3)\nS=joStack(A,B,C;weights=w) # weighted stack\n\nNotes\n\nall operators must have the same # of columns (N)\nall given operators must have same domain/range types\nthe domain/range types of joStack are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joStack-Union{Tuple{WDT}, Tuple{Integer,joAbstractLinearOperator}} where WDT<:Number","page":"JOLI reference","title":"JOLI.joStack","text":"Stack operator composed from l-times replicated square JOLI operator\n\njoStack(l::Int,op::joAbstractLinearOperator;\n    weights::LocalVector,name::String)\n\nExample\n\na=rand(ComplexF64,4,4);\nw=rand(ComplexF64,3)\nA=joMatrix(a;DDT=ComplexF32,RDT=ComplexF64,name=\"A\")\nS=joStack(3,A) # basic stack\nS=joStack(3,A;weights=w) # weighted stack\n\nNotes\n\nall operators must have the same # of columns (N)\nall given operators must have same domain/range types\nthe domain/range types of joStack are equal to domain/range types of the given operators\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.joZeros","page":"JOLI reference","title":"JOLI.joZeros","text":"julia> op = joZeros(m[,n];[DDT=...,][RDT=...,][name=...])\n\nOperator equivalent to matrix of ones\n\nSignature\n\njoZeros(m::Integer,n::Integer=m;\n    DDT::DataType=joFloat,RDT::DataType=DDT,name::String=\"joZeros\")\n\nArguments\n\nm: size\noptional\nn: 2nd dimension if not square\nkeywords\nDDT: domain data type\nRDT: range data type\nname: custom name\n\nExamples\n\njoZeros(m)\njoZeros(m,n)\n\nexamples with DDT/RDT\n\njoZeros(m; DDT=Float32)\njoZeros(m; DDT=Float32,RDT=Float64)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_PAmode-Tuple{Symbol}","page":"JOLI reference","title":"JOLI.jo_PAmode","text":"\n\n\n\n","category":"method"},{"location":"#JOLI.jo_balanced_partition","page":"JOLI reference","title":"JOLI.jo_balanced_partition","text":"julia> jo_balanced_partition(nlabs::Integer,dsize::Integer)\n\nGet balanced partitioning of the dimension (dsize) on n workers (nlabs)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_check_type_match-Tuple{DataType,DataType,String}","page":"JOLI reference","title":"JOLI.jo_check_type_match","text":"Check type match\n\njo_check_type_match(DT1::DataType,DT2::DataType,where::String)\n\nThe bahaviour of the function while types do not match depends on values of jotypemismatchwarn and jotypemismatcherror flags. Use jotypemismatcherrorset to toggle those flags from warning mode to error mode.\n\nEXAMPLE\n\njochecktype_match(Float32,Float64,\"my session\")\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_complex_eltype-Tuple{DataType}","page":"JOLI reference","title":"JOLI.jo_complex_eltype","text":"Type of element of complex data type\n\njo_complex_eltype(DT::DataType)\n\nExample\n\njocomplexeltype(ComplexF32)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_complex_eltype-Union{Tuple{Complex{T}}, Tuple{T}} where T","page":"JOLI reference","title":"JOLI.jo_complex_eltype","text":"Type of element of complex scalar\n\njo_complex_eltype(a::Complex)\n\nExample\n\njocomplexeltype(1.+im*1.)\njocomplexeltype(zero(ComplexF64))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_convert-Union{Tuple{NT}, Tuple{DataType,NT}, Tuple{DataType,NT,Bool}} where NT<:Integer","page":"JOLI reference","title":"JOLI.jo_convert","text":"Convert number to new type\n\njo_convert(DT::DataType,n::Number,warning::Bool=true)\n\nLimitations\n\nconverting integer number to shorter representation will throw an error\nconverting float/complex number to integer will throw an error\nconverting from complex to float drops immaginary part and issues warning; use joconvertwarn_set(false) to turn off the warning\n\nExample\n\njo_convert(ComplexF32,rand())\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_convert-Union{Tuple{VT}, Tuple{DataType,AbstractArray{VT,N} where N}, Tuple{DataType,AbstractArray{VT,N} where N,Bool}} where VT<:Integer","page":"JOLI reference","title":"JOLI.jo_convert","text":"Convert vector to new type\n\njo_convert(DT::DataType,v::AbstractArray,warning::Bool=true)\n\nLimitations\n\nconverting integer array to shorter representation will throw an error\nconverting float/complex array to integer will throw an error\nconverting from complex to float drops immaginary part and issues warning; use joconvertwarn_set(false) to turn off the warning\n\nExample\n\njo_convert(ComplexF32,rand(3))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_convert_warn_set-Tuple{Bool}","page":"JOLI reference","title":"JOLI.jo_convert_warn_set","text":"Set warning mode for jo_convert\n\njo_convert_warn_set(flag::Bool)\n\nExample\n\njoconvertwarn_set(false) turns of the warnings\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_eye","page":"JOLI reference","title":"JOLI.jo_eye","text":"return identity array\n\njo_eye(m::Integer,n::Integer=m)\njo_eye(DT::DataType,m::Integer,n::Integer=m)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_full-Tuple{AbstractArray}","page":"JOLI reference","title":"JOLI.jo_full","text":"return full array\n\njo_full(A::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_iterative_solver4square_set-Tuple{Function}","page":"JOLI reference","title":"JOLI.jo_iterative_solver4square_set","text":"Set default iterative solver for (jo,vec) and square jo\n\njo_iterative_solver4square_set(f::Function)\n\nWhere f must take two arguments (jo,vec) and return vec.\n\nExample (using IterativeSolvers)\n\njoiterativesolver4square_set((A,v)->gmres(A,v))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_iterative_solver4tall_set-Tuple{Function}","page":"JOLI reference","title":"JOLI.jo_iterative_solver4tall_set","text":"Set default iterative solver for (jo,vec) and tall jo\n\njo_iterative_solver4tall_set(f::Function)\n\nWhere f must take two arguments (jo,vec) and return vec.\n\nExample\n\njoiterativesolver4tallset((A,v)->tallsolve(A,v))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_iterative_solver4wide_set-Tuple{Function}","page":"JOLI reference","title":"JOLI.jo_iterative_solver4wide_set","text":"Set default iterative solver for (jo,vec) and wide jo\n\njo_iterative_solver4wide_set(f::Function)\n\nWhere f must take two arguments (jo,vec) and return vec.\n\nExample\n\njoiterativesolver4wideset((A,v)->widesolve(A,v))\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_jo32bit_set-Tuple{}","page":"JOLI reference","title":"JOLI.jo_jo32bit_set","text":"set default type joInt, joFloat, joComplex to 32 bit\n\nfunction jo_jo32bit_set()\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_jo64bit_set-Tuple{}","page":"JOLI reference","title":"JOLI.jo_jo64bit_set","text":"set default type joInt, joFloat, joComplex to 64 bit\n\nfunction jo_jo64bit_set()\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_joComplex_set","page":"JOLI reference","title":"JOLI.jo_joComplex_set","text":"set default complex type joComplex\n\nfunction jo_joComplex_set(DT::DataType=joComplex)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_joFloat_set","page":"JOLI reference","title":"JOLI.jo_joFloat_set","text":"set default float type joFloat\n\nfunction jo_joFloat_set(DT::DataType=joFloat)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_joInt_set","page":"JOLI reference","title":"JOLI.jo_joInt_set","text":"set default integer type joInt\n\nfunction jo_joInt_set(DT::DataType=joInt)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_joTypes_get-Tuple{}","page":"JOLI reference","title":"JOLI.jo_joTypes_get","text":"get default types joInt, joFloat, joComplex\n\nfunction jo_joTypes_get()\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_precision_type-Union{Tuple{Tx}, Tuple{Tx}, Tuple{ITx}} where Tx<:Union{Complex{ITx}, ITx} where ITx<:Number","page":"JOLI reference","title":"JOLI.jo_precision_type","text":"Type of the real number or element type of complex number.\n\nExample\n\njoprecisiontype(1.)\njoprecisiontype(1+im*3.)\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_speye","page":"JOLI reference","title":"JOLI.jo_speye","text":"return sparse identity array\n\njo_speye(m::Integer,n::Integer=m)\njo_speye(DT::DataType,m::Integer,n::Integer=m)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.jo_type_mismatch_error_set-Tuple{Bool}","page":"JOLI reference","title":"JOLI.jo_type_mismatch_error_set","text":"Toggle between warning and error for type mismatch\n\njo_type_mismatch_error_set(flag::Bool)\n\nExamples\n\njotypemismatcherrorset(false) turns on warnings instead of errors\njotypemismatcherrorset(true) reverts to errors\n\n\n\n\n\n","category":"method"},{"location":"#JOLI.jo_type_tree","page":"JOLI reference","title":"JOLI.jo_type_tree","text":"Show type tree of JOLI operators, or any type with editional Type argument.\n\njo_type_tree()\njo_type_tree(Number)\n\n\n\n\n\n","category":"function"},{"location":"#JOLI.salloc-Tuple{joPAsetup}","page":"JOLI reference","title":"JOLI.salloc","text":"julia> salloc(d; [DT])\n\nAllocates a SharedArray according to given distributor\n\nSignature\n\nsalloc(d::joPAsetup;DT::DataType=d.DT)\n\nArguments\n\nd: see help for joPAsetup\nDT: keyword argument to overwrite the type in joPAsetup\n\nExamples\n\nsalloc(d): allocate an array\nsalloc(d,DT=Float32): allocate array and overwite d.DT with Float32\n\n\n\n\n\n","category":"method"},{"location":"#Constants-1","page":"JOLI reference","title":"Constants","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:constant]","category":"page"},{"location":"#Macros-1","page":"JOLI reference","title":"Macros","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"Modules = [JOLI]\nOrder = [:macro]","category":"page"},{"location":"#JOLI.@joNF-Tuple{Expr}","page":"JOLI reference","title":"JOLI.@joNF","text":"Nullable{Function} macro for given function\n\n@joNF ... | @joNF(...)\n\n\n\n\n\n","category":"macro"},{"location":"#JOLI.@joNF-Tuple{}","page":"JOLI reference","title":"JOLI.@joNF","text":"Nullable{Function} macro for null function\n\n@joNF\n\n\n\n\n\n","category":"macro"},{"location":"#Index-1","page":"JOLI reference","title":"Index","text":"","category":"section"},{"location":"#","page":"JOLI reference","title":"JOLI reference","text":"","category":"page"}]
}
